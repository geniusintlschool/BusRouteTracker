<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus No 4 Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #333;
            font-size: 16px;
            font-weight: 500;
        }

        .error-message {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: #ffebee;
            border: 1px solid #f44336;
            border-radius: 4px;
            padding: 12px;
            color: #c62828;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }

        .bus-info-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            white-space: nowrap;
            pointer-events: none;
            max-width: 200px;
            text-align: center;
        }



        /* Custom popup styles */
        .custom-popup {
            font-family: inherit;
        }

        .custom-popup h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 14px;
        }

        .custom-popup p {
            margin: 4px 0;
            color: #666;
            font-size: 12px;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px;
                width: calc(100% - 20px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="map"></div>
        
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading bus data...</div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        
        <div id="lastUpdate" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;">
            Last Update: Loading...
        </div>

    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global error handling for unhandled promise rejections
        window.addEventListener('unhandledrejection', event => {
            console.warn('Unhandled promise rejection:', event.reason);
            event.preventDefault(); // Prevent the default browser behavior
        });

        class BusTracker {
            constructor() {
                this.map = null;
                this.currentLocationMarker = null;
                this.busInfoLabel = null;
                this.routeLayer = null;
                this.stopMarkers = [];
                this.historicalRoute = [];
                this.busStops = [];
                this.routeCoordinates = [];
                this.lastBusLocation = null;
                this.lastSpeed = 0;
                this.isInitialLoad = true;
                this.movementInterval = null;
                this.currentDirection = null;
                this.isMoving = false;
                this.stopTimer = null;
                this.isAtStop = false;
                this.currentStopName = null;
                
                // API Configuration
                this.ORS_API_KEY = '5b3ce3597851110001cf62486ef5d938c6804787a401d0a56b3236ae';
                this.SHEETS_BASE_URL = 'https://opensheet.elk.sh/1Jnsrz4MoEgjQJ2UjcPB20e4sxd_3TMWAMQ_lq9HAUOs';
                
                // Bus configuration
                this.BUS_NUMBER = 4;
                
                this.initializeMap();
                this.loadInitialData();
                this.startLocationUpdates();
                
                // Safety timeout to hide loading if it gets stuck
                setTimeout(() => {
                    if (this.isInitialLoad) {
                        console.warn('Force hiding loading overlay after 30 seconds');
                        this.showLoading(false);
                        this.isInitialLoad = false;
                    }
                }, 30000);
            }

            initializeMap() {
                // Initialize map centered on a default location (will be adjusted when data loads)
                this.map = L.map('map').setView([28.6139, 77.2090], 13);

                // Add OpenStreetMap tile layer (more reliable)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.map);

                // Update bus info label position when map moves
                this.map.on('move zoom', () => {
                    if (this.lastBusLocation && this.busInfoLabel) {
                        this.updateBusInfoLabel(this.lastBusLocation);
                    }
                });
            }

            async loadInitialData() {
                let bus4Locations = [];
                try {
                    this.showLoading(true);
                    
                    // Fetch data from all three endpoints
                    const [busLocations, busHistory, busStops] = await Promise.all([
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusHistory`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusStops`)
                    ]);

                    // Filter data for Bus No 4
                    bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    const bus4History = this.filterHistoricalData(busHistory);
                    this.busStops = busStops.filter(stop => parseInt(stop['Bus Number']) === this.BUS_NUMBER);

                    console.log(`Found ${bus4Locations.length} current locations for Bus No 4`);
                    console.log(`Found ${this.busStops.length} bus stops for Bus No 4`);

                    // Process and display static data (routes and stops - load once)
                    await this.displayHistoricalRoute(bus4History);
                    this.displayBusStops(this.busStops);
                    
                    // Display current location and zoom to it
                    await this.displayCurrentLocation(bus4Locations, true);
                    
                    this.updateLastUpdateTime();
                    this.showLoading(false);
                    this.isInitialLoad = false;
                    console.log('Initial load completed successfully, updates enabled');
                    
                } catch (error) {
                    console.error('Error loading bus data:', error);
                    // Always hide loading and enable updates, even on error
                    this.showLoading(false);
                    this.isInitialLoad = false;
                    
                    // Show appropriate error message
                    if (!bus4Locations || bus4Locations.length === 0) {
                        this.showError('Failed to load bus location data. Please check your internet connection and try again.');
                    }
                }
            }

            async updateBusLocation() {
                try {
                    console.log('Updating bus location...');
                    // Only fetch current location data
                    const busLocations = await this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`);
                    const bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    
                    console.log(`Update: Found ${bus4Locations.length} locations for Bus No 4`);
                    
                    if (bus4Locations.length > 0) {
                        const currentLocation = bus4Locations[bus4Locations.length - 1];
                        console.log('Update: Latest location:', {
                            lat: currentLocation['Latitude'],
                            lng: currentLocation['Longitude'],
                            time: currentLocation['Time'],
                            speed: currentLocation['Speed'],
                            ignition: currentLocation['Ignition']
                        });
                        
                        try {
                            await this.displayCurrentLocation(bus4Locations, false);
                            console.log('Update: Display location completed');
                        } catch (e) {
                            console.error('Error in displayCurrentLocation:', e.message);
                        }
                        
                        try {
                            this.updateLastUpdateTime();
                            console.log('Update: Last update time updated');
                        } catch (e) {
                            console.error('Error in updateLastUpdateTime:', e.message);
                        }
                        
                        try {
                            this.checkETAAlerts();
                            console.log('Update: ETA alerts checked');
                        } catch (e) {
                            console.error('Error in checkETAAlerts:', e.message);
                        }
                        
                        console.log('Update: Location updated successfully');
                    } else {
                        console.warn('Update: No Bus No 4 locations found');
                    }
                } catch (error) {
                    console.error('Failed to update bus location:', error);
                    console.error('Error details:', error.message, error.stack);
                    // Don't show error to user for routine updates, but log details
                }
            }

            startLocationUpdates() {
                // Update bus location every 60 seconds
                console.log('Starting 60-second location update timer');
                
                // Start updates immediately after 60 seconds, regardless of initial load
                setInterval(() => {
                    console.log('Timer triggered: calling updateBusLocation()');
                    this.updateBusLocation();
                }, 60000);
            }

            async fetchData(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch data from ${url}:`, error);
                    throw error; // Re-throw to be handled by calling function
                }
            }

            filterHistoricalData(busHistory) {
                // Use data from 6/25/2025 as requested
                const targetDate = '6/25/2025';
                const startHour = 15; // 3:30 PM
                const endHour = 17; // 5:30 PM
                
                const bus4Records = busHistory.filter(record => {
                    return parseInt(record['Bus Number']) === this.BUS_NUMBER;
                });
                
                console.log(`Found ${bus4Records.length} total Bus No 4 records`);
                
                const filteredRecords = bus4Records.filter(record => {
                    const recordTime = record['Time'];
                    if (!recordTime) return false;
                    
                    try {
                        const recordDateStr = recordTime.split(' ')[0]; // Get date part
                        const recordDate = new Date(recordTime);
                        const recordHour = recordDate.getHours();
                        
                        const matches = recordDateStr === targetDate && 
                                       recordHour >= startHour && 
                                       recordHour <= endHour;
                        
                        return matches;
                    } catch (error) {
                        console.warn('Error parsing date:', recordTime, error);
                        return false;
                    }
                });
                
                console.log(`Filtered to ${filteredRecords.length} records for ${targetDate} between ${startHour}:00-${endHour}:00`);
                
                // If no data in specified time range, use any available Bus 4 data from that date
                if (filteredRecords.length === 0) {
                    const dayRecords = bus4Records.filter(record => {
                        const recordTime = record['Time'];
                        return recordTime && recordTime.split(' ')[0] === targetDate;
                    });
                    console.log(`No data in time range, using ${dayRecords.length} records from entire day`);
                    return dayRecords.slice(0, 50); // Limit to 50 points for performance
                }
                
                // Sort by time to ensure proper route order
                filteredRecords.sort((a, b) => {
                    const timeA = new Date(a['Time']);
                    const timeB = new Date(b['Time']);
                    return timeA - timeB;
                });
                
                return filteredRecords;
            }

            async displayCurrentLocation(busLocations, shouldZoom = false) {
                if (busLocations.length === 0) {
                    console.warn('No current location data found for Bus No 4');
                    return;
                }

                // Get the most recent location
                const currentLocation = busLocations[busLocations.length - 1];
                const lat = parseFloat(currentLocation['Latitude']);
                const lng = parseFloat(currentLocation['Longitude']);
                const speed = parseFloat(currentLocation['Speed']) || 0;
                const ignition = currentLocation['Ignition'];

                if (isNaN(lat) || isNaN(lng)) {
                    console.warn('Invalid coordinates for current location');
                    return;
                }

                // Store ignition status for ETA calculations
                this.busIgnition = ignition;
                console.log(`Bus ignition status: "${ignition}" (type: ${typeof ignition})`);

                // Create custom yellow bus icon with direction
                const busIcon = L.divIcon({
                    className: 'bus-icon',
                    html: `
                        <div style="
                            background-color: #ffd700;
                            width: 35px;
                            height: 35px;
                            border-radius: 50%;
                            border: 3px solid #fff;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 18px;
                            animation: pulse 2s infinite;
                        ">ð</div>
                        <style>
                            @keyframes pulse {
                                0% { transform: scale(1); }
                                50% { transform: scale(1.1); }
                                100% { transform: scale(1); }
                            }
                        </style>
                    `,
                    iconSize: [35, 35],
                    iconAnchor: [17, 17]
                });

                const newLocation = [lat, lng];

                if (this.currentLocationMarker) {
                    // Smooth transition to new location
                    if (this.lastBusLocation) {
                        console.log(`Animating bus from [${this.lastBusLocation[0].toFixed(6)}, ${this.lastBusLocation[1].toFixed(6)}] to [${newLocation[0].toFixed(6)}, ${newLocation[1].toFixed(6)}] at ${speed} km/h`);
                        this.animateBusMovement(this.lastBusLocation, newLocation, speed);
                    } else {
                        console.log('Initial bus position set');
                        this.currentLocationMarker.setLatLng(newLocation);
                        this.startContinuousMovement(speed);
                    }
                    
                    // Update popup content
                    this.currentLocationMarker.setPopupContent(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                            <p><strong>Speed:</strong> ${speed} km/h</p>
                            <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                            <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                            <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                        </div>
                    `);
                } else {
                    // Create new marker
                    this.currentLocationMarker = L.marker(newLocation, { icon: busIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                                <p><strong>Speed:</strong> ${speed} km/h</p>
                                <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                                <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                                <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                            </div>
                        `);
                }

                // Store current data and update movement
                this.lastBusLocation = newLocation;
                this.lastSpeed = speed;
                
                // Update bus info label with movement status
                this.updateBusInfoLabelWithSpeed(newLocation, speed, ignition);

            }

            updateBusInfoLabelWithSpeed(location, speed, ignition, customStatus = null) {
                const statusText = customStatus ? customStatus :
                                  speed > 0 ? `Moving at ${speed} km/h` : 
                                  ignition === 'ON' ? 'Stopped (10s pause)' : 'Parked';
                
                if (!this.busInfoLabel) {
                    this.busInfoLabel = document.createElement('div');
                    this.busInfoLabel.className = 'bus-info-label';
                    document.body.appendChild(this.busInfoLabel);
                }

                this.busInfoLabel.innerHTML = `
                    <div><strong>Bus No ${this.BUS_NUMBER}</strong></div>
                    <div>${statusText}</div>
                    <div>Ignition: ${ignition}</div>
                `;

                // Position label next to bus
                const busPixelPosition = this.map.latLngToContainerPoint(location);
                this.busInfoLabel.style.left = (busPixelPosition.x + 45) + 'px';
                this.busInfoLabel.style.top = (busPixelPosition.y - 15) + 'px';
                this.busInfoLabel.style.display = 'block';
            }

            animateBusMovement(fromLocation, toLocation, speed) {
                // Stop any existing movement to prevent conflicts
                this.stopContinuousMovement();
                
                // Calculate direction for continuous movement
                const latDiff = toLocation[0] - fromLocation[0];
                const lngDiff = toLocation[1] - fromLocation[1];
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                
                // Always update direction when we have GPS movement
                if (distance > 0) {
                    this.currentDirection = {
                        lat: latDiff / distance,
                        lng: lngDiff / distance
                    };
                    console.log(`GPS movement: ${(distance * 111000).toFixed(0)}m, direction updated`);
                }
                
                // For any GPS update, smoothly transition to new position
                if (distance > 0) {
                    // Calculate transition time based on distance and speed
                    const transitionTime = Math.min(3000, Math.max(1000, distance * 10000)); // 1-3 seconds
                    const steps = 30;
                    let currentStep = 0;
                    
                    console.log(`Smooth GPS transition: ${steps} steps over ${transitionTime}ms`);
                    
                    const smoothTransition = setInterval(() => {
                        currentStep++;
                        const progress = currentStep / steps;
                        const easedProgress = this.easeInOutQuad(progress);
                        
                        const currentLat = fromLocation[0] + (latDiff * easedProgress);
                        const currentLng = fromLocation[1] + (lngDiff * easedProgress);
                        
                        this.currentLocationMarker.setLatLng([currentLat, currentLng]);
                        this.updateBusInfoLabel([currentLat, currentLng]);
                        
                        if (currentStep >= steps) {
                            clearInterval(smoothTransition);
                            this.currentLocationMarker.setLatLng(toLocation);
                            this.updateBusInfoLabel(toLocation);
                            this.lastBusLocation = toLocation;
                            
                            // Start continuous movement simulation
                            this.startContinuousMovement(speed);
                        }
                    }, transitionTime / steps);
                } else {
                    // No GPS movement - use existing position and direction
                    console.log(`No GPS movement - continuing with speed: ${speed} km/h`);
                    this.lastBusLocation = toLocation;
                    
                    // Ensure we have movement direction from route if none exists
                    if (!this.currentDirection) {
                        this.currentDirection = this.calculateMovementDirection();
                        console.log('Using route direction for stationary GPS');
                    }
                    
                    // Start continuous movement simulation
                    this.startContinuousMovement(speed);
                }
            }
            
            startContinuousMovement(speed) {
                // Clear any existing movement
                this.stopContinuousMovement();
                
                // Track last speed for resuming after stops
                if (speed > 0) {
                    this.lastSpeed = speed;
                }
                
                // Initialize stop tracking variables
                this.isAtStop = false;
                this.currentStopName = null;
                
                if (speed === 0) {
                    // Bus is stopped - pause for 10 seconds
                    this.isMoving = false;
                    this.updateBusInfoLabelWithSpeed(this.currentLocationMarker.getLatLng(), speed, this.busIgnition);
                    console.log('Bus stopped - pausing for 10 seconds');
                    
                    this.stopTimer = setTimeout(() => {
                        console.log('Stop period ended - checking if bus should resume movement');
                        this.stopTimer = null;
                        
                        // After pause, check if we should resume movement with last known speed
                        if (this.lastSpeed > 0 && this.currentDirection) {
                            console.log(`Resuming movement at last speed: ${this.lastSpeed} km/h`);
                            this.startContinuousMovement(this.lastSpeed);
                        }
                    }, 10000);
                    return;
                }
                
                // Ensure we have a movement direction for continuous movement
                if (!this.currentDirection) {
                    // Calculate direction from route or use last known GPS movement
                    this.currentDirection = this.calculateMovementDirection() || { lat: 0.0001, lng: 0.0001 };
                    console.log('Created movement direction for continuous movement:', this.currentDirection);
                }
                
                // More accurate speed conversion
                const avgLat = this.currentLocationMarker ? this.currentLocationMarker.getLatLng().lat : 11.7;
                const metersPerSecond = speed / 3.6; // Convert km/h to m/s
                const degreesPerMeter = 1 / 111320; // More precise: 1 degree â 111,320 meters
                const degreesPerSecond = metersPerSecond * degreesPerMeter;
                
                if (speed === 0) {
                    console.log('Speed is 0 - continuous movement will not start');
                    return;
                }
                
                const updateInterval = 100; // Update every 100ms for smooth movement
                
                this.isMoving = true;
                this.updateBusInfoLabelWithSpeed(this.currentLocationMarker.getLatLng(), speed, this.busIgnition);
                console.log(`Starting continuous movement at ${speed} km/h (${metersPerSecond.toFixed(2)} m/s) with direction:`, this.currentDirection);
                
                this.movementInterval = setInterval(() => {
                    if (!this.currentLocationMarker || !this.currentDirection || !this.isMoving) {
                        console.log('Movement stopped - marker, direction or isMoving false');
                        return;
                    }
                    
                    const currentPos = this.currentLocationMarker.getLatLng();
                    const moveDistance = degreesPerSecond * (updateInterval / 1000);
                    
                    const newLat = currentPos.lat + (this.currentDirection.lat * moveDistance);
                    const newLng = currentPos.lng + (this.currentDirection.lng * moveDistance);
                    
                    // Check if bus is near any bus stop (within 50 meters)
                    const newPosition = [newLat, newLng];
                    const nearbyStop = this.checkNearbyBusStop(newPosition);
                    
                    if (nearbyStop && !this.isAtStop) {
                        // Bus reached a stop - pause for 10 seconds
                        console.log(`Bus reached ${nearbyStop.stop['Stop Name']} - pausing for 10 seconds`);
                        this.isAtStop = true;
                        this.currentStopName = nearbyStop.stop['Stop Name'];
                        
                        // Update position to exact stop location
                        this.currentLocationMarker.setLatLng(nearbyStop.coordinates);
                        this.updateBusInfoLabelWithSpeed(nearbyStop.coordinates, 0, this.busIgnition, `At ${nearbyStop.stop['Stop Name']}`);
                        
                        // Resume movement after 10 seconds
                        setTimeout(() => {
                            console.log(`Resuming movement from ${this.currentStopName}`);
                            this.isAtStop = false;
                            this.currentStopName = null;
                        }, 10000);
                        
                        return;
                    }
                    
                    // Normal movement if not at stop
                    if (!this.isAtStop) {
                        this.currentLocationMarker.setLatLng([newLat, newLng]);
                        // Update info label without recalculating ETA during simulation
                        this.updateBusInfoLabelWithSpeed([newLat, newLng], speed, this.busIgnition);
                    }
                    
                }, updateInterval);
            }
            
            stopContinuousMovement() {
                if (this.movementInterval) {
                    clearInterval(this.movementInterval);
                    this.movementInterval = null;
                }
                if (this.stopTimer) {
                    clearTimeout(this.stopTimer);
                    this.stopTimer = null;
                }
                this.isMoving = false;
            }
            
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            calculateMovementDirection() {
                // Try to determine movement direction from route data
                if (this.routeLayer && this.routeLayer.getLatLngs) {
                    const routePoints = this.routeLayer.getLatLngs();
                    if (routePoints.length > 1) {
                        // Find closest route point and use direction along route
                        const busPos = this.currentLocationMarker ? this.currentLocationMarker.getLatLng() : null;
                        if (busPos) {
                            let closestIndex = 0;
                            let minDistance = Infinity;
                            
                            routePoints.forEach((point, index) => {
                                const distance = busPos.distanceTo(point);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestIndex = index;
                                }
                            });
                            
                            // Use direction from current point to next point on route
                            if (closestIndex < routePoints.length - 1) {
                                const current = routePoints[closestIndex];
                                const next = routePoints[closestIndex + 1];
                                const latDiff = next.lat - current.lat;
                                const lngDiff = next.lng - current.lng;
                                const magnitude = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                                
                                if (magnitude > 0) {
                                    return {
                                        lat: latDiff / magnitude,
                                        lng: lngDiff / magnitude
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Fallback: use general eastward direction
                return { lat: 0, lng: 0.0001 };
            }

            checkNearbyBusStop(position) {
                if (!this.stopMarkers || this.stopMarkers.length === 0) {
                    return null;
                }
                
                const busLatLng = L.latLng(position[0], position[1]);
                const stopRadius = 50; // 50 meters detection radius
                
                for (let stopData of this.stopMarkers) {
                    const stopLatLng = L.latLng(stopData.coordinates[0], stopData.coordinates[1]);
                    const distance = busLatLng.distanceTo(stopLatLng); // Distance in meters
                    
                    if (distance <= stopRadius) {
                        return stopData;
                    }
                }
                
                return null;
            }

            animateBusMovement(fromLatLng, toLatLng, speed) {
                const duration = Math.max(1000, Math.min(5000, 15000 - (speed * 100))); // Adjust animation speed
                const steps = 30;
                let currentStep = 0;
                
                const latDiff = toLatLng[0] - fromLatLng[0];
                const lngDiff = toLatLng[1] - fromLatLng[1];
                
                const animate = () => {
                    currentStep++;
                    const progress = currentStep / steps;
                    
                    // Easing function for smooth movement
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    const currentLat = fromLatLng[0] + (latDiff * easeProgress);
                    const currentLng = fromLatLng[1] + (lngDiff * easeProgress);
                    
                    this.currentLocationMarker.setLatLng([currentLat, currentLng]);
                    
                    // Update bus info label position during animation
                    if (this.busInfoLabel) {
                        this.updateBusInfoLabel([currentLat, currentLng]);
                    }
                    
                    if (currentStep < steps) {
                        setTimeout(animate, duration / steps);
                    }
                };
                
                animate();
            }

            updateBusInfoLabel(busLocation) {
                let labelText = `Bus No ${this.BUS_NUMBER}`;
                
                // Check if bus is idle (ignition OFF)
                if (this.busIgnition === 'OFF' || this.busIgnition === 'FALSE' || this.busIgnition === false) {
                    labelText += ', IDLE';
                } else {
                    const etas = this.calculateETA();
                    if (etas.length > 0) {
                        const nextStop = etas[0];
                        labelText += `, ${nextStop.eta} mins to ${nextStop.stop['Stop Name']}`;
                    } else {
                        labelText += ', Calculating ETA...';
                    }
                }
                
                if (!this.busInfoLabel) {
                    // Create the label element
                    this.busInfoLabel = document.createElement('div');
                    this.busInfoLabel.className = 'bus-info-label';
                    document.body.appendChild(this.busInfoLabel);
                }
                
                // Update label text
                this.busInfoLabel.textContent = labelText;
                
                // Position the label next to the bus icon
                const busPixelPosition = this.map.latLngToContainerPoint(busLocation);
                const labelWidth = this.busInfoLabel.offsetWidth || 150;
                
                // Position to the right of the bus icon with some offset
                this.busInfoLabel.style.left = (busPixelPosition.x + 45) + 'px';
                this.busInfoLabel.style.top = (busPixelPosition.y - 15) + 'px';
                
                // Keep label visible on screen
                const mapContainer = this.map.getContainer();
                const mapWidth = mapContainer.offsetWidth;
                const mapHeight = mapContainer.offsetHeight;
                
                // Adjust position if label would go off-screen
                if (busPixelPosition.x + 45 + labelWidth > mapWidth) {
                    this.busInfoLabel.style.left = (busPixelPosition.x - labelWidth - 45) + 'px';
                }
                
                if (busPixelPosition.y - 15 < 0) {
                    this.busInfoLabel.style.top = (busPixelPosition.y + 45) + 'px';
                }
            }

            async displayHistoricalRoute(historicalData) {
                // Use the provided filtered route coordinates for Bus No 4
                const routeCoordinates = [
                    [11.707203, 76.178753], [11.707203, 76.178753], [11.707043, 76.178674], [11.703089, 76.176372],
                    [11.70215, 76.175898], [11.699329, 76.174175], [11.698983, 76.173874], [11.69897, 76.173627],
                    [11.69897, 76.173627], [11.693091, 76.175683], [11.693091, 76.175683], [11.693091, 76.175683],
                    [11.692489, 76.171257], [11.692894, 76.169505], [11.690033, 76.163223], [11.690155, 76.162754],
                    [11.690275, 76.162408], [11.69037, 76.161508], [11.690206, 76.160369], [11.690047, 76.163146],
                    [11.690286, 76.163855], [11.691306, 76.165319], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.68323, 76.1649], [11.68323, 76.1649], [11.679817, 76.16187], [11.674429, 76.158919],
                    [11.674429, 76.158919], [11.673687, 76.157864], [11.673431, 76.156758], [11.670298, 76.150902],
                    [11.672108, 76.148321], [11.672297, 76.147892], [11.672262, 76.148062], [11.66598, 76.157013],
                    [11.665356, 76.158277], [11.665356, 76.158277], [11.663222, 76.160824], [11.658865, 76.16108],
                    [11.657806, 76.160551], [11.65776, 76.160523], [11.65776, 76.160523], [11.653527, 76.154115],
                    [11.65327, 76.143409], [11.652043, 76.142324], [11.651361, 76.141892], [11.651361, 76.141892],
                    [11.638766, 76.145734], [11.638079, 76.147841], [11.636767, 76.149675], [11.631102, 76.150658],
                    [11.623348, 76.156827], [11.619435, 76.15801], [11.619255, 76.158062], [11.61907, 76.158193],
                    [11.619354, 76.167932], [11.619354, 76.167932], [11.617481, 76.160904], [11.619013, 76.158224],
                    [11.619173, 76.158089], [11.629105, 76.152701], [11.62928, 76.15247], [11.638774, 76.145684],
                    [11.639721, 76.14539], [11.640015, 76.145458], [11.650805, 76.141346], [11.649996, 76.140488],
                    [11.649307, 76.137058], [11.649246, 76.134996], [11.649136, 76.132484], [11.648907, 76.128197],
                    [11.64229, 76.110991], [11.641959, 76.110759], [11.641778, 76.110718], [11.641778, 76.110718],
                    [11.641694, 76.110861], [11.63811, 76.101998], [11.636936, 76.10055], [11.63609, 76.0916],
                    [11.634211, 76.090231], [11.634222, 76.090191], [11.634222, 76.090191], [11.636535, 76.097234],
                    [11.637145, 76.100888], [11.641326, 76.109974]
                ];

                console.log(`Displaying route with ${routeCoordinates.length} coordinate points`);

                try {
                    // Attempt to get road-snapped route from OpenRouteService
                    const snappedRoute = await this.getSnappedRoute(routeCoordinates);
                    
                    if (snappedRoute && snappedRoute.length > 0) {
                        console.log(`Got snapped route with ${snappedRoute.length} points`);
                        
                        // Create route polyline using snapped coordinates with arrows
                        this.routeLayer = L.polyline(snappedRoute, {
                            color: '#ff9800',
                            weight: 4,
                            opacity: 0.8
                        }).addTo(this.map);

                        // Direction arrows removed - confusing on bidirectional roads

                        // Add popup to route
                        this.routeLayer.bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                                <p><strong>Date:</strong> June 25, 2025</p>
                                <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                                <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                                <p><em>Road-snapped route via OpenRouteService</em></p>
                            </div>
                        `);
                    } else {
                        throw new Error('No snapped route returned');
                    }
                } catch (error) {
                    console.warn('Road snapping failed, using GPS coordinates:', error.message);
                    
                    // Fallback: Create route polyline using the filtered coordinates
                    this.routeLayer = L.polyline(routeCoordinates, {
                        color: '#ff9800',
                        weight: 4,
                        opacity: 0.8,
                        dashArray: '10, 5'
                    }).addTo(this.map);

                    // Add popup to route
                    this.routeLayer.bindPopup(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                            <p><strong>Date:</strong> June 25, 2025</p>
                            <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                            <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                            <p><em>GPS trail (road snapping unavailable)</em></p>
                        </div>
                    `);
                }

                // Fit map to show the complete route
                this.map.fitBounds(this.routeLayer.getBounds(), { padding: [20, 20] });
            }

            async getSnappedRoute(coordinates) {
                try {
                    // Fetch pre-computed snapped route from SnappedRoutes sheet
                    console.log('Fetching pre-computed snapped route from SnappedRoutes sheet');
                    const snappedData = await this.fetchData(`${this.SHEETS_BASE_URL}/SnappedRoutes`);
                    
                    // Filter for Bus No 4 route (June 25, 3:30-5:30 PM)
                    const bus4SnappedRoute = snappedData.filter(row => 
                        row['Route Name'] === 'Bus4_June25_1530_1730'
                    );
                    
                    if (bus4SnappedRoute.length > 0) {
                        // Sort by point order and convert to coordinate pairs
                        bus4SnappedRoute.sort((a, b) => parseInt(a['Point Order']) - parseInt(b['Point Order']));
                        
                        const snappedCoords = bus4SnappedRoute.map(row => [
                            parseFloat(row['Latitude']),
                            parseFloat(row['Longitude'])
                        ]);
                        
                        console.log(`â Using pre-computed snapped route with ${snappedCoords.length} points`);
                        return snappedCoords;
                    } else {
                        console.warn('No pre-computed snapped route found, using GPS coordinates');
                        return [];
                    }
                    
                } catch (error) {
                    console.error('Error fetching snapped route:', error);
                    console.log('Falling back to GPS coordinates');
                    return [];
                }
            }

            // Convert degrees/minutes/seconds to decimal degrees
            convertDMSToDecimal(dmsString) {
                try {
                    // Handle format like "11Â°38'04.3"N " or "76Â°05'24.8"E"
                    // Remove all quotes, extra spaces, and clean the string
                    const cleanString = dmsString.replace(/"/g, '').trim().replace(/\s+/g, '');
                    
                    // Match pattern: degreesÂ°minutes'seconds"direction or degreesÂ°minutes'secondsdirection
                    const parts = cleanString.match(/(\d+)Â°(\d+)'([\d.]+)([NSEW])/);
                    
                    if (!parts) {
                        console.warn('Could not parse DMS string:', dmsString, 'cleaned to:', cleanString);
                        return NaN;
                    }
                    
                    const degrees = parseInt(parts[1]);
                    const minutes = parseInt(parts[2]);
                    const seconds = parseFloat(parts[3]);
                    const direction = parts[4];
                    
                    let decimal = degrees + (minutes / 60) + (seconds / 3600);
                    
                    if (direction === 'S' || direction === 'W') {
                        decimal = -decimal;
                    }
                    
                    return decimal;
                } catch (error) {
                    console.warn('Error converting DMS to decimal:', dmsString, error);
                    return NaN;
                }
            }

            displayBusStops(busStops) {
                console.log(`Processing ${busStops.length} bus stops`);
                
                // Determine if this is morning or evening run based on current time
                const currentHour = new Date().getHours();
                const isEveningRun = currentHour >= 15; // After 3 PM is evening run
                const orderColumn = isEveningRun ? 'Evening Order' : 'Morning Order';
                
                console.log(`Using ${orderColumn} for bus stop ordering (current hour: ${currentHour})`);
                
                // Sort bus stops by the appropriate order column
                const sortedStops = busStops.sort((a, b) => {
                    const orderA = parseInt(a[orderColumn]) || 999;
                    const orderB = parseInt(b[orderColumn]) || 999;
                    return orderA - orderB;
                });
                
                sortedStops.forEach((stop, index) => {
                    let lat, lng;
                    
                    // Check if coordinates are in DMS format (contain Â° character)
                    if (stop['Latitude'].includes('Â°')) {
                        lat = this.convertDMSToDecimal(stop['Latitude']);
                        lng = this.convertDMSToDecimal(stop['Longitude']);
                    } else {
                        lat = parseFloat(stop['Latitude']);
                        lng = parseFloat(stop['Longitude']);
                    }

                    if (isNaN(lat) || isNaN(lng)) {
                        console.warn(`Invalid coordinates for stop: ${stop['Stop Name']}`, stop['Latitude'], stop['Longitude']);
                        return;
                    }
                    
                    const stopOrder = parseInt(stop[orderColumn]) || (index + 1);

                    // Create bus stop icon
                    const stopIcon = L.divIcon({
                        className: 'stop-icon',
                        html: `
                            <div style="
                                background-color: #2196f3;
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                border: 2px solid #fff;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                color: white;
                                font-size: 10px;
                                font-weight: bold;
                            ">${stopOrder}</div>
                        `,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const marker = L.marker([lat, lng], { icon: stopIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>${stop['Stop Name'] || 'Bus Stop'}</h4>
                                <p><strong>Bus Number:</strong> ${stop['Bus Number']}</p>
                                <p><strong>${orderColumn}:</strong> ${stopOrder}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        `);

                    this.stopMarkers.push({
                        marker: marker,
                        stop: stop,
                        order: stopOrder,
                        coordinates: [lat, lng]
                    });
                });
            }

            addDirectionArrows(routeCoordinates) {
                // Add arrow markers at regular intervals along the route
                const arrowInterval = Math.floor(routeCoordinates.length / 15); // About 15 arrows
                
                for (let i = arrowInterval; i < routeCoordinates.length - arrowInterval; i += arrowInterval) {
                    const current = routeCoordinates[i];
                    const next = routeCoordinates[i + 1];
                    
                    if (current && next) {
                        // Calculate bearing for arrow direction
                        const bearing = this.calculateBearing(current, next);
                        
                        const arrowIcon = L.divIcon({
                            className: 'arrow-icon',
                            html: `
                                <div style="
                                    width: 0;
                                    height: 0;
                                    border-left: 8px solid transparent;
                                    border-right: 8px solid transparent;
                                    border-bottom: 12px solid #ff9800;
                                    transform: rotate(${bearing}deg);
                                    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
                                "></div>
                            `,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        });
                        
                        L.marker(current, { icon: arrowIcon }).addTo(this.map);
                    }
                }
            }

            calculateBearing(from, to) {
                const lat1 = from[0] * Math.PI / 180;
                const lat2 = to[0] * Math.PI / 180;
                const deltaLon = (to[1] - from[1]) * Math.PI / 180;
                
                const y = Math.sin(deltaLon) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
                
                const bearing = Math.atan2(y, x) * 180 / Math.PI;
                return (bearing + 360) % 360;
            }

            calculateDistance(point1, point2) {
                const R = 6371; // Earth's radius in km
                const lat1 = point1[0] * Math.PI / 180;
                const lat2 = point2[0] * Math.PI / 180;
                const deltaLat = (point2[0] - point1[0]) * Math.PI / 180;
                const deltaLon = (point2[1] - point1[1]) * Math.PI / 180;
                
                const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(deltaLon/2) * Math.sin(deltaLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c; // Distance in km
            }

            calculateETA() {
                if (!this.lastBusLocation || this.stopMarkers.length === 0 || this.lastSpeed <= 0) {
                    return [];
                }
                
                const busLocation = this.lastBusLocation;
                const speed = Math.max(this.lastSpeed, 5); // Minimum 5 km/h for calculation
                
                // Find next stops based on order sequence, not route position
                const nextStops = this.findNextStopsInOrder(busLocation);
                const etas = [];
                
                console.log(`Found ${nextStops.length} upcoming stops:`, nextStops.map(s => `${s.order}: ${s.stop['Stop Name']}`));
                
                // Calculate ETA for next stops following the order
                nextStops.forEach(stopData => {
                    const distance = this.calculateDistance(busLocation, stopData.coordinates);
                    const timeInHours = distance / speed;
                    const timeInMinutes = Math.round(timeInHours * 60);
                    
                    console.log(`ETA to ${stopData.stop['Stop Name']} (order ${stopData.order}): ${timeInMinutes} mins (${distance.toFixed(2)} km)`);
                    
                    etas.push({
                        stop: stopData.stop,
                        order: stopData.order,
                        distance: distance,
                        eta: timeInMinutes
                    });
                });
                
                return etas;
            }

            findNextStopsInOrder(busLocation) {
                if (this.stopMarkers.length === 0) return [];
                
                // Find the next upcoming stops based on distance from current position
                // Calculate distance to all stops and find the closest one
                let currentStopIndex = -1;
                let minDistance = Infinity;
                
                this.stopMarkers.forEach((stopData, index) => {
                    const distance = this.calculateDistance(busLocation, stopData.coordinates);
                    if (distance < minDistance) {
                        minDistance = distance;
                        currentStopIndex = index;
                    }
                });
                
                // Find the next stops that haven't been passed yet
                const nextStops = [];
                
                // Start from the closest stop and look for upcoming stops
                console.log(`Closest stop: ${this.stopMarkers[currentStopIndex]?.stop['Stop Name']} at ${minDistance.toFixed(3)} km`);
                
                // Find the stops that are actually ahead in the route sequence
                // Look at all stops and find those with higher order numbers that are reasonable distance away
                
                for (let i = 0; i < this.stopMarkers.length && nextStops.length < 5; i++) {
                    const stopData = this.stopMarkers[i];
                    const distance = this.calculateDistance(busLocation, stopData.coordinates);
                    
                    // Include stops that are:
                    // 1. More than 100m away (to avoid showing stops we just passed)
                    // 2. Have a higher order number than the closest stop (ahead in sequence)
                    // 3. Or are more than 500m away from bus (far enough to be considered upcoming)
                    
                    const isAheadInSequence = stopData.order > (this.stopMarkers[currentStopIndex]?.order || 0);
                    const isFarEnoughToBeUpcoming = distance > 0.5; // 500 meters
                    const isNotTooClose = distance > 0.1; // Not within 100 meters
                    
                    if (isNotTooClose && (isAheadInSequence || isFarEnoughToBeUpcoming)) {
                        nextStops.push(stopData);
                        console.log(`Added upcoming stop: ${stopData.stop['Stop Name']} (order ${stopData.order}) - ${distance.toFixed(2)}km away`);
                    }
                }
                
                // Sort by order to maintain sequence
                nextStops.sort((a, b) => a.order - b.order);
                
                // If we ran out of stops in the sequence, we might be near the end of route
                if (nextStops.length === 0 && currentStopIndex >= this.stopMarkers.length - 1) {
                    console.log('Bus appears to be at or past the final stop');
                    return [];
                }
                
                // If still no stops found, take from current position
                if (nextStops.length === 0 && currentStopIndex >= 0) {
                    for (let i = currentStopIndex; i < this.stopMarkers.length && nextStops.length < 5; i++) {
                        nextStops.push(this.stopMarkers[i]);
                    }
                }
                
                return nextStops;
            }

            findNextStopsOnRoute(busLocation) {
                if (!this.routeLayer || !this.routeLayer.getLatLngs || this.stopMarkers.length === 0) {
                    // Fallback to distance-based sorting if route not available
                    return this.stopMarkers
                        .map(stop => ({
                            ...stop,
                            distanceFromBus: this.calculateDistance(busLocation, stop.coordinates)
                        }))
                        .sort((a, b) => a.distanceFromBus - b.distanceFromBus);
                }
                
                const routePoints = this.routeLayer.getLatLngs();
                const busLatLng = L.latLng(busLocation[0], busLocation[1]);
                
                // Find bus position on route
                let closestRouteIndex = 0;
                let minDistanceToRoute = Infinity;
                
                routePoints.forEach((point, index) => {
                    const distance = busLatLng.distanceTo(point);
                    if (distance < minDistanceToRoute) {
                        minDistanceToRoute = distance;
                        closestRouteIndex = index;
                    }
                });
                
                // Find stops ahead on the route
                const nextStops = [];
                
                this.stopMarkers.forEach(stopData => {
                    const stopLatLng = L.latLng(stopData.coordinates[0], stopData.coordinates[1]);
                    
                    // Find closest route point to this stop
                    let closestStopRouteIndex = 0;
                    let minDistanceToStopRoute = Infinity;
                    
                    routePoints.forEach((point, index) => {
                        const distance = stopLatLng.distanceTo(point);
                        if (distance < minDistanceToStopRoute) {
                            minDistanceToStopRoute = distance;
                            closestStopRouteIndex = index;
                        }
                    });
                    
                    // If stop is ahead of bus on route, include it
                    if (closestStopRouteIndex > closestRouteIndex) {
                        nextStops.push({
                            ...stopData,
                            routeIndex: closestStopRouteIndex,
                            distanceFromBus: this.calculateDistance(busLocation, stopData.coordinates)
                        });
                    }
                });
                
                // Sort by route order (position along route)
                return nextStops.sort((a, b) => a.routeIndex - b.routeIndex);
            }

            checkETAAlerts() {
                const etas = this.calculateETA();
                
                etas.forEach(eta => {
                    // Alert for 5 minutes or less
                    if (eta.eta <= 5 && eta.eta > 0) {
                        console.log(`ETA Alert: Bus No ${this.BUS_NUMBER} is ${eta.eta} mins away from ${eta.stop['Stop Name']} stop`);
                        this.showAlert(`Bus No ${this.BUS_NUMBER} will reach ${eta.stop['Stop Name']} stop in ${eta.eta} minutes`);
                    }
                    // Alert for 10 minutes or less (but more than 5)
                    else if (eta.eta <= 10 && eta.eta > 5) {
                        console.log(`ETA Alert: Bus No ${this.BUS_NUMBER} is ${eta.eta} mins away from ${eta.stop['Stop Name']} stop`);
                        this.showAlert(`Bus No ${this.BUS_NUMBER} will reach ${eta.stop['Stop Name']} stop in ${eta.eta} minutes`);
                    }
                });
                
                // Update ETA display in popup if it exists
                const etaElement = document.getElementById('next-stop-eta');
                if (etaElement && etas.length > 0) {
                    const nextStop = etas[0];
                    etaElement.textContent = `${nextStop.eta} mins to ${nextStop.stop['Stop Name']}`;
                }
            }

            showAlert(message) {
                // Create alert notification
                const alertDiv = document.createElement('div');
                alertDiv.className = 'eta-alert';
                alertDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background-color: #4caf50;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                    z-index: 10000;
                    font-size: 14px;
                    max-width: 300px;
                    animation: slideIn 0.3s ease-out;
                `;
                alertDiv.textContent = message;
                
                // Add animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(alertDiv);
                
                // Remove alert after 5 seconds
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.remove();
                    }
                }, 5000);
                
                console.log(`ETA Alert: ${message}`);
            }

            updateLastUpdateTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = `Last Update: ${timeString}`;
            }

            showLoading(show) {
                const overlay = document.getElementById('loadingOverlay');
                overlay.style.display = show ? 'flex' : 'none';
            }

            showError(message) {
                const errorElement = document.getElementById('errorMessage');
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 10000);
            }

            // Method to refresh data (can be called externally)
            async refresh() {
                await this.updateBusLocation();
            }
        }

        // Initialize the bus tracker when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.busTracker = new BusTracker();
        });

        // Telegram Web App specific initialization
        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>
