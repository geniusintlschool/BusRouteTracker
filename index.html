<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus No 4 Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #333;
            font-size: 16px;
            font-weight: 500;
        }

        .error-message {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: #ffebee;
            border: 1px solid #f44336;
            border-radius: 4px;
            padding: 12px;
            color: #c62828;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }

        .bus-info-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            white-space: nowrap;
            pointer-events: none;
            max-width: 200px;
            text-align: center;
        }



        /* Custom popup styles */
        .custom-popup {
            font-family: inherit;
        }

        .custom-popup h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 14px;
        }

        .custom-popup p {
            margin: 4px 0;
            color: #666;
            font-size: 12px;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px;
                width: calc(100% - 20px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="map"></div>
        
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading bus data...</div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        
        <div id="lastUpdate" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;">
            Last Update: Loading...
        </div>

    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global error handling for unhandled promise rejections
        window.addEventListener('unhandledrejection', event => {
            console.warn('Unhandled promise rejection:', event.reason);
            event.preventDefault(); // Prevent the default browser behavior
        });

        class BusTracker {
            constructor() {
                this.map = null;
                this.currentLocationMarker = null;
                this.busInfoLabel = null;
                this.routeLayer = null;
                this.stopMarkers = [];
                this.historicalRoute = [];
                this.busStops = [];
                this.routeCoordinates = [];
                this.lastBusLocation = null;
                this.lastSpeed = 0;
                this.isInitialLoad = true;
                
                // API Configuration
                this.ORS_API_KEY = '5b3ce3597851110001cf62486ef5d938c6804787a401d0a56b3236ae';
                this.SHEETS_BASE_URL = 'https://opensheet.elk.sh/1Jnsrz4MoEgjQJ2UjcPB20e4sxd_3TMWAMQ_lq9HAUOs';
                
                // Bus configuration
                this.BUS_NUMBER = 4;
                
                this.initializeMap();
                this.loadInitialData();
                this.startLocationUpdates();
            }

            initializeMap() {
                // Initialize map centered on a default location (will be adjusted when data loads)
                this.map = L.map('map').setView([28.6139, 77.2090], 13);

                // Add OpenStreetMap tile layer (more reliable)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.map);

                // Update bus info label position when map moves
                this.map.on('move zoom', () => {
                    if (this.lastBusLocation && this.busInfoLabel) {
                        this.updateBusInfoLabel(this.lastBusLocation);
                    }
                });
            }

            async loadInitialData() {
                let bus4Locations = [];
                try {
                    this.showLoading(true);
                    
                    // Fetch data from all three endpoints
                    const [busLocations, busHistory, busStops] = await Promise.all([
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusHistory`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusStops`)
                    ]);

                    // Filter data for Bus No 4
                    bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    const bus4History = this.filterHistoricalData(busHistory);
                    this.busStops = busStops.filter(stop => parseInt(stop['Bus Number']) === this.BUS_NUMBER);

                    console.log(`Found ${bus4Locations.length} current locations for Bus No 4`);
                    console.log(`Found ${this.busStops.length} bus stops for Bus No 4`);

                    // Process and display static data (routes and stops - load once)
                    await this.displayHistoricalRoute(bus4History);
                    this.displayBusStops(this.busStops);
                    
                    // Display current location and zoom to it
                    await this.displayCurrentLocation(bus4Locations, true);
                    
                    this.updateLastUpdateTime();
                    this.showLoading(false);
                    this.isInitialLoad = false;
                    console.log('Initial load completed successfully, updates enabled');
                    
                } catch (error) {
                    console.error('Error loading bus data:', error);
                    // Show appropriate error message
                    if (bus4Locations.length === 0) {
                        this.showError('Failed to load bus location data. Please check your internet connection and try again.');
                    }
                    this.showLoading(false);
                    // Always set initial load to false, even on error, so updates can start
                    this.isInitialLoad = false;
                }
            }

            async updateBusLocation() {
                try {
                    console.log('Updating bus location...');
                    // Only fetch current location data
                    const busLocations = await this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`);
                    const bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    
                    console.log(`Update: Found ${bus4Locations.length} locations for Bus No 4`);
                    
                    if (bus4Locations.length > 0) {
                        const currentLocation = bus4Locations[bus4Locations.length - 1];
                        console.log('Update: Latest location:', {
                            lat: currentLocation['Latitude'],
                            lng: currentLocation['Longitude'],
                            time: currentLocation['Time'],
                            speed: currentLocation['Speed'],
                            ignition: currentLocation['Ignition']
                        });
                        
                        try {
                            await this.displayCurrentLocation(bus4Locations, false);
                            console.log('Update: Display location completed');
                        } catch (e) {
                            console.error('Error in displayCurrentLocation:', e.message);
                        }
                        
                        try {
                            this.updateLastUpdateTime();
                            console.log('Update: Last update time updated');
                        } catch (e) {
                            console.error('Error in updateLastUpdateTime:', e.message);
                        }
                        
                        try {
                            this.checkETAAlerts();
                            console.log('Update: ETA alerts checked');
                        } catch (e) {
                            console.error('Error in checkETAAlerts:', e.message);
                        }
                        
                        console.log('Update: Location updated successfully');
                    } else {
                        console.warn('Update: No Bus No 4 locations found');
                    }
                } catch (error) {
                    console.error('Failed to update bus location:', error);
                    console.error('Error details:', error.message, error.stack);
                    // Don't show error to user for routine updates, but log details
                }
            }

            startLocationUpdates() {
                // Update bus location every 15 seconds
                console.log('Starting 15-second location update timer');
                
                // Start updates immediately after 15 seconds, regardless of initial load
                setInterval(() => {
                    console.log('Timer triggered: calling updateBusLocation()');
                    this.updateBusLocation();
                }, 15000);
            }

            async fetchData(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch data from ${url}:`, error);
                    throw error; // Re-throw to be handled by calling function
                }
            }

            filterHistoricalData(busHistory) {
                // Use data from 6/25/2025 as requested
                const targetDate = '6/25/2025';
                const startHour = 15; // 3:30 PM
                const endHour = 17; // 5:30 PM
                
                const bus4Records = busHistory.filter(record => {
                    return parseInt(record['Bus Number']) === this.BUS_NUMBER;
                });
                
                console.log(`Found ${bus4Records.length} total Bus No 4 records`);
                
                const filteredRecords = bus4Records.filter(record => {
                    const recordTime = record['Time'];
                    if (!recordTime) return false;
                    
                    try {
                        const recordDateStr = recordTime.split(' ')[0]; // Get date part
                        const recordDate = new Date(recordTime);
                        const recordHour = recordDate.getHours();
                        
                        const matches = recordDateStr === targetDate && 
                                       recordHour >= startHour && 
                                       recordHour <= endHour;
                        
                        return matches;
                    } catch (error) {
                        console.warn('Error parsing date:', recordTime, error);
                        return false;
                    }
                });
                
                console.log(`Filtered to ${filteredRecords.length} records for ${targetDate} between ${startHour}:00-${endHour}:00`);
                
                // If no data in specified time range, use any available Bus 4 data from that date
                if (filteredRecords.length === 0) {
                    const dayRecords = bus4Records.filter(record => {
                        const recordTime = record['Time'];
                        return recordTime && recordTime.split(' ')[0] === targetDate;
                    });
                    console.log(`No data in time range, using ${dayRecords.length} records from entire day`);
                    return dayRecords.slice(0, 50); // Limit to 50 points for performance
                }
                
                // Sort by time to ensure proper route order
                filteredRecords.sort((a, b) => {
                    const timeA = new Date(a['Time']);
                    const timeB = new Date(b['Time']);
                    return timeA - timeB;
                });
                
                return filteredRecords;
            }

            async displayCurrentLocation(busLocations, shouldZoom = false) {
                if (busLocations.length === 0) {
                    console.warn('No current location data found for Bus No 4');
                    return;
                }

                // Get the most recent location
                const currentLocation = busLocations[busLocations.length - 1];
                const lat = parseFloat(currentLocation['Latitude']);
                const lng = parseFloat(currentLocation['Longitude']);
                const speed = parseFloat(currentLocation['Speed']) || 0;
                const ignition = currentLocation['Ignition'];

                if (isNaN(lat) || isNaN(lng)) {
                    console.warn('Invalid coordinates for current location');
                    return;
                }

                // Store ignition status for ETA calculations
                this.busIgnition = ignition;
                console.log(`Bus ignition status: "${ignition}" (type: ${typeof ignition})`);

                // Create custom yellow bus icon with direction
                const busIcon = L.divIcon({
                    className: 'bus-icon',
                    html: `
                        <div style="
                            background-color: #ffd700;
                            width: 35px;
                            height: 35px;
                            border-radius: 50%;
                            border: 3px solid #fff;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 18px;
                            animation: pulse 2s infinite;
                        ">ðŸšŒ</div>
                        <style>
                            @keyframes pulse {
                                0% { transform: scale(1); }
                                50% { transform: scale(1.1); }
                                100% { transform: scale(1); }
                            }
                        </style>
                    `,
                    iconSize: [35, 35],
                    iconAnchor: [17, 17]
                });

                const newLocation = [lat, lng];

                if (this.currentLocationMarker) {
                    // Smooth transition to new location
                    if (this.lastBusLocation) {
                        this.animateBusMovement(this.lastBusLocation, newLocation, speed);
                    } else {
                        this.currentLocationMarker.setLatLng(newLocation);
                    }
                    
                    // Update popup content
                    this.currentLocationMarker.setPopupContent(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                            <p><strong>Speed:</strong> ${speed} km/h</p>
                            <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                            <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                            <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                        </div>
                    `);
                } else {
                    // Create new marker
                    this.currentLocationMarker = L.marker(newLocation, { icon: busIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                                <p><strong>Speed:</strong> ${speed} km/h</p>
                                <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                                <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                                <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                            </div>
                        `);
                }

                // Store current data
                this.lastBusLocation = newLocation;
                this.lastSpeed = speed;

                // Update or create bus info label
                this.updateBusInfoLabel(newLocation);

                // Only zoom on initial load or when requested
                if (shouldZoom) {
                    this.map.setView(newLocation, 16);
                }
            }

            animateBusMovement(fromLatLng, toLatLng, speed) {
                const duration = Math.max(1000, Math.min(5000, 15000 - (speed * 100))); // Adjust animation speed
                const steps = 30;
                let currentStep = 0;
                
                const latDiff = toLatLng[0] - fromLatLng[0];
                const lngDiff = toLatLng[1] - fromLatLng[1];
                
                const animate = () => {
                    currentStep++;
                    const progress = currentStep / steps;
                    
                    // Easing function for smooth movement
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    const currentLat = fromLatLng[0] + (latDiff * easeProgress);
                    const currentLng = fromLatLng[1] + (lngDiff * easeProgress);
                    
                    this.currentLocationMarker.setLatLng([currentLat, currentLng]);
                    
                    // Update bus info label position during animation
                    if (this.busInfoLabel) {
                        this.updateBusInfoLabel([currentLat, currentLng]);
                    }
                    
                    if (currentStep < steps) {
                        setTimeout(animate, duration / steps);
                    }
                };
                
                animate();
            }

            updateBusInfoLabel(busLocation) {
                let labelText = `Bus No ${this.BUS_NUMBER}`;
                
                // Check if bus is idle (ignition OFF)
                if (this.busIgnition === 'OFF' || this.busIgnition === 'FALSE' || this.busIgnition === false) {
                    labelText += ', IDLE';
                } else {
                    const etas = this.calculateETA();
                    if (etas.length > 0) {
                        const nextStop = etas[0];
                        labelText += `, ${nextStop.eta} mins to ${nextStop.stop['Stop Name']}`;
                    } else {
                        labelText += ', Calculating ETA...';
                    }
                }
                
                if (!this.busInfoLabel) {
                    // Create the label element
                    this.busInfoLabel = document.createElement('div');
                    this.busInfoLabel.className = 'bus-info-label';
                    document.body.appendChild(this.busInfoLabel);
                }
                
                // Update label text
                this.busInfoLabel.textContent = labelText;
                
                // Position the label next to the bus icon
                const busPixelPosition = this.map.latLngToContainerPoint(busLocation);
                const labelWidth = this.busInfoLabel.offsetWidth || 150;
                
                // Position to the right of the bus icon with some offset
                this.busInfoLabel.style.left = (busPixelPosition.x + 45) + 'px';
                this.busInfoLabel.style.top = (busPixelPosition.y - 15) + 'px';
                
                // Keep label visible on screen
                const mapContainer = this.map.getContainer();
                const mapWidth = mapContainer.offsetWidth;
                const mapHeight = mapContainer.offsetHeight;
                
                // Adjust position if label would go off-screen
                if (busPixelPosition.x + 45 + labelWidth > mapWidth) {
                    this.busInfoLabel.style.left = (busPixelPosition.x - labelWidth - 45) + 'px';
                }
                
                if (busPixelPosition.y - 15 < 0) {
                    this.busInfoLabel.style.top = (busPixelPosition.y + 45) + 'px';
                }
            }

            async displayHistoricalRoute(historicalData) {
                // Use the provided filtered route coordinates for Bus No 4
                const routeCoordinates = [
                    [11.707203, 76.178753], [11.707203, 76.178753], [11.707043, 76.178674], [11.703089, 76.176372],
                    [11.70215, 76.175898], [11.699329, 76.174175], [11.698983, 76.173874], [11.69897, 76.173627],
                    [11.69897, 76.173627], [11.693091, 76.175683], [11.693091, 76.175683], [11.693091, 76.175683],
                    [11.692489, 76.171257], [11.692894, 76.169505], [11.690033, 76.163223], [11.690155, 76.162754],
                    [11.690275, 76.162408], [11.69037, 76.161508], [11.690206, 76.160369], [11.690047, 76.163146],
                    [11.690286, 76.163855], [11.691306, 76.165319], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.68323, 76.1649], [11.68323, 76.1649], [11.679817, 76.16187], [11.674429, 76.158919],
                    [11.674429, 76.158919], [11.673687, 76.157864], [11.673431, 76.156758], [11.670298, 76.150902],
                    [11.672108, 76.148321], [11.672297, 76.147892], [11.672262, 76.148062], [11.66598, 76.157013],
                    [11.665356, 76.158277], [11.665356, 76.158277], [11.663222, 76.160824], [11.658865, 76.16108],
                    [11.657806, 76.160551], [11.65776, 76.160523], [11.65776, 76.160523], [11.653527, 76.154115],
                    [11.65327, 76.143409], [11.652043, 76.142324], [11.651361, 76.141892], [11.651361, 76.141892],
                    [11.638766, 76.145734], [11.638079, 76.147841], [11.636767, 76.149675], [11.631102, 76.150658],
                    [11.623348, 76.156827], [11.619435, 76.15801], [11.619255, 76.158062], [11.61907, 76.158193],
                    [11.619354, 76.167932], [11.619354, 76.167932], [11.617481, 76.160904], [11.619013, 76.158224],
                    [11.619173, 76.158089], [11.629105, 76.152701], [11.62928, 76.15247], [11.638774, 76.145684],
                    [11.639721, 76.14539], [11.640015, 76.145458], [11.650805, 76.141346], [11.649996, 76.140488],
                    [11.649307, 76.137058], [11.649246, 76.134996], [11.649136, 76.132484], [11.648907, 76.128197],
                    [11.64229, 76.110991], [11.641959, 76.110759], [11.641778, 76.110718], [11.641778, 76.110718],
                    [11.641694, 76.110861], [11.63811, 76.101998], [11.636936, 76.10055], [11.63609, 76.0916],
                    [11.634211, 76.090231], [11.634222, 76.090191], [11.634222, 76.090191], [11.636535, 76.097234],
                    [11.637145, 76.100888], [11.641326, 76.109974]
                ];

                console.log(`Displaying route with ${routeCoordinates.length} coordinate points`);

                try {
                    // Attempt to get road-snapped route from OpenRouteService
                    const snappedRoute = await this.getSnappedRoute(routeCoordinates);
                    
                    if (snappedRoute && snappedRoute.length > 0) {
                        console.log(`Got snapped route with ${snappedRoute.length} points`);
                        
                        // Create route polyline using snapped coordinates with arrows
                        this.routeLayer = L.polyline(snappedRoute, {
                            color: '#ff9800',
                            weight: 4,
                            opacity: 0.8
                        }).addTo(this.map);

                        // Add direction arrows to the route
                        this.addDirectionArrows(snappedRoute);

                        // Add popup to route
                        this.routeLayer.bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                                <p><strong>Date:</strong> June 25, 2025</p>
                                <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                                <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                                <p><em>Road-snapped route via OpenRouteService</em></p>
                            </div>
                        `);
                    } else {
                        throw new Error('No snapped route returned');
                    }
                } catch (error) {
                    console.warn('Road snapping failed, using GPS coordinates:', error.message);
                    
                    // Fallback: Create route polyline using the filtered coordinates
                    this.routeLayer = L.polyline(routeCoordinates, {
                        color: '#ff9800',
                        weight: 4,
                        opacity: 0.8,
                        dashArray: '10, 5'
                    }).addTo(this.map);

                    // Add popup to route
                    this.routeLayer.bindPopup(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                            <p><strong>Date:</strong> June 25, 2025</p>
                            <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                            <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                            <p><em>GPS trail (road snapping unavailable)</em></p>
                        </div>
                    `);
                }

                // Fit map to show the complete route
                this.map.fitBounds(this.routeLayer.getBounds(), { padding: [20, 20] });
            }

            async getSnappedRoute(coordinates) {
                try {
                    // Break the route into segments to handle the full route
                    const segmentSize = 10; // Points per segment
                    const allSnappedCoords = [];
                    
                    // Filter to key points first
                    const keyPoints = coordinates.filter((coord, index) => 
                        index % 2 === 0 || index === coordinates.length - 1
                    );
                    
                    console.log(`Processing ${keyPoints.length} key points in segments of ${segmentSize}`);
                    
                    for (let i = 0; i < keyPoints.length; i += segmentSize - 1) {
                        const segment = keyPoints.slice(i, i + segmentSize);
                        if (segment.length < 2) break;
                        
                        // Convert [lat, lng] to [lng, lat] for OpenRouteService
                        const orsCoords = segment.map(coord => [coord[1], coord[0]]);
                        
                        console.log(`Snapping segment ${Math.floor(i/(segmentSize-1)) + 1} with ${orsCoords.length} points`);
                        
                        const response = await fetch('https://api.openrouteservice.org/v2/directions/driving-car/geojson', {
                            method: 'POST',
                            headers: {
                                'Authorization': this.ORS_API_KEY,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                coordinates: orsCoords,
                                radiuses: orsCoords.map(() => 1000),
                                continue_straight: false
                            })
                        }).catch(error => {
                            console.warn(`Network error for segment ${Math.floor(i/(segmentSize-1)) + 1}:`, error);
                            return { ok: false, status: 'network_error' };
                        });

                        if (response.ok) {
                            const data = await response.json();
                            const routeGeometry = data.features[0]?.geometry?.coordinates;
                            
                            if (routeGeometry && routeGeometry.length > 0) {
                                // Convert back to [lat, lng] and add to combined route
                                const segmentCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
                                
                                // Avoid duplicate points between segments
                                if (allSnappedCoords.length > 0) {
                                    segmentCoords.shift(); // Remove first point to avoid duplication
                                }
                                
                                allSnappedCoords.push(...segmentCoords);
                            }
                        } else {
                            console.warn(`Segment ${Math.floor(i/(segmentSize-1)) + 1} failed, status: ${response.status}`);
                        }
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    console.log(`Combined snapped route has ${allSnappedCoords.length} total points`);
                    return allSnappedCoords;
                    
                } catch (error) {
                    console.error('Error getting snapped route:', error);
                    return [];
                }
            }

            // Convert degrees/minutes/seconds to decimal degrees
            convertDMSToDecimal(dmsString) {
                try {
                    // Handle format like "11Â°38'04.3"N " or "76Â°05'24.8"E"
                    // Remove all quotes, extra spaces, and clean the string
                    const cleanString = dmsString.replace(/"/g, '').trim().replace(/\s+/g, '');
                    
                    // Match pattern: degreesÂ°minutes'seconds"direction or degreesÂ°minutes'secondsdirection
                    const parts = cleanString.match(/(\d+)Â°(\d+)'([\d.]+)([NSEW])/);
                    
                    if (!parts) {
                        console.warn('Could not parse DMS string:', dmsString, 'cleaned to:', cleanString);
                        return NaN;
                    }
                    
                    const degrees = parseInt(parts[1]);
                    const minutes = parseInt(parts[2]);
                    const seconds = parseFloat(parts[3]);
                    const direction = parts[4];
                    
                    let decimal = degrees + (minutes / 60) + (seconds / 3600);
                    
                    if (direction === 'S' || direction === 'W') {
                        decimal = -decimal;
                    }
                    
                    return decimal;
                } catch (error) {
                    console.warn('Error converting DMS to decimal:', dmsString, error);
                    return NaN;
                }
            }

            displayBusStops(busStops) {
                console.log(`Processing ${busStops.length} bus stops`);
                
                // Sort bus stops by order number
                const sortedStops = busStops.sort((a, b) => {
                    const orderA = parseInt(a['Order']) || 999;
                    const orderB = parseInt(b['Order']) || 999;
                    return orderA - orderB;
                });
                
                sortedStops.forEach((stop, index) => {
                    let lat, lng;
                    
                    // Check if coordinates are in DMS format (contain Â° character)
                    if (stop['Latitude'].includes('Â°')) {
                        lat = this.convertDMSToDecimal(stop['Latitude']);
                        lng = this.convertDMSToDecimal(stop['Longitude']);
                    } else {
                        lat = parseFloat(stop['Latitude']);
                        lng = parseFloat(stop['Longitude']);
                    }

                    if (isNaN(lat) || isNaN(lng)) {
                        console.warn(`Invalid coordinates for stop: ${stop['Stop Name']}`, stop['Latitude'], stop['Longitude']);
                        return;
                    }
                    
                    const stopOrder = parseInt(stop['Order']) || (index + 1);

                    // Create bus stop icon
                    const stopIcon = L.divIcon({
                        className: 'stop-icon',
                        html: `
                            <div style="
                                background-color: #2196f3;
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                border: 2px solid #fff;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                color: white;
                                font-size: 10px;
                                font-weight: bold;
                            ">${stopOrder}</div>
                        `,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const marker = L.marker([lat, lng], { icon: stopIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>${stop['Stop Name'] || 'Bus Stop'}</h4>
                                <p><strong>Bus Number:</strong> ${stop['Bus Number']}</p>
                                <p><strong>Order:</strong> ${stop['Order'] || index + 1}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        `);

                    this.stopMarkers.push({
                        marker: marker,
                        stop: stop,
                        order: stopOrder,
                        coordinates: [lat, lng]
                    });
                });
            }

            addDirectionArrows(routeCoordinates) {
                // Add arrow markers at regular intervals along the route
                const arrowInterval = Math.floor(routeCoordinates.length / 15); // About 15 arrows
                
                for (let i = arrowInterval; i < routeCoordinates.length - arrowInterval; i += arrowInterval) {
                    const current = routeCoordinates[i];
                    const next = routeCoordinates[i + 1];
                    
                    if (current && next) {
                        // Calculate bearing for arrow direction
                        const bearing = this.calculateBearing(current, next);
                        
                        const arrowIcon = L.divIcon({
                            className: 'arrow-icon',
                            html: `
                                <div style="
                                    width: 0;
                                    height: 0;
                                    border-left: 8px solid transparent;
                                    border-right: 8px solid transparent;
                                    border-bottom: 12px solid #ff9800;
                                    transform: rotate(${bearing}deg);
                                    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
                                "></div>
                            `,
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        });
                        
                        L.marker(current, { icon: arrowIcon }).addTo(this.map);
                    }
                }
            }

            calculateBearing(from, to) {
                const lat1 = from[0] * Math.PI / 180;
                const lat2 = to[0] * Math.PI / 180;
                const deltaLon = (to[1] - from[1]) * Math.PI / 180;
                
                const y = Math.sin(deltaLon) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
                
                const bearing = Math.atan2(y, x) * 180 / Math.PI;
                return (bearing + 360) % 360;
            }

            calculateDistance(point1, point2) {
                const R = 6371; // Earth's radius in km
                const lat1 = point1[0] * Math.PI / 180;
                const lat2 = point2[0] * Math.PI / 180;
                const deltaLat = (point2[0] - point1[0]) * Math.PI / 180;
                const deltaLon = (point2[1] - point1[1]) * Math.PI / 180;
                
                const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(deltaLon/2) * Math.sin(deltaLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c; // Distance in km
            }

            calculateETA() {
                if (!this.lastBusLocation || this.stopMarkers.length === 0 || this.lastSpeed <= 0) {
                    return [];
                }
                
                const busLocation = this.lastBusLocation;
                const speed = Math.max(this.lastSpeed, 5); // Minimum 5 km/h for calculation
                const etas = [];
                
                // Get next 5 stops
                const sortedStops = this.stopMarkers
                    .sort((a, b) => a.order - b.order)
                    .slice(0, 5);
                
                sortedStops.forEach(stopData => {
                    const distance = this.calculateDistance(busLocation, stopData.coordinates);
                    const timeInHours = distance / speed;
                    const timeInMinutes = Math.round(timeInHours * 60);
                    
                    etas.push({
                        stop: stopData.stop,
                        order: stopData.order,
                        distance: distance,
                        eta: timeInMinutes
                    });
                });
                
                return etas;
            }

            checkETAAlerts() {
                const etas = this.calculateETA();
                
                etas.forEach(eta => {
                    if (eta.eta <= 5 && eta.eta > 0) {
                        this.showAlert(`Bus No ${this.BUS_NUMBER} is ${eta.eta} mins away from ${eta.stop['Stop Name']} stop`);
                    }
                });
                
                // Update ETA display in popup if it exists
                const etaElement = document.getElementById('next-stop-eta');
                if (etaElement && etas.length > 0) {
                    const nextStop = etas[0];
                    etaElement.textContent = `${nextStop.eta} mins to ${nextStop.stop['Stop Name']}`;
                }
            }

            showAlert(message) {
                // Create alert notification
                const alertDiv = document.createElement('div');
                alertDiv.className = 'eta-alert';
                alertDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background-color: #4caf50;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                    z-index: 10000;
                    font-size: 14px;
                    max-width: 300px;
                    animation: slideIn 0.3s ease-out;
                `;
                alertDiv.textContent = message;
                
                // Add animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(alertDiv);
                
                // Remove alert after 5 seconds
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.remove();
                    }
                }, 5000);
                
                console.log(`ETA Alert: ${message}`);
            }

            updateLastUpdateTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = `Last Update: ${timeString}`;
            }

            showLoading(show) {
                const overlay = document.getElementById('loadingOverlay');
                overlay.style.display = show ? 'flex' : 'none';
            }

            showError(message) {
                const errorElement = document.getElementById('errorMessage');
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 10000);
            }

            // Method to refresh data (can be called externally)
            async refresh() {
                await this.updateBusLocation();
            }
        }

        // Initialize the bus tracker when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.busTracker = new BusTracker();
        });

        // Telegram Web App specific initialization
        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>
