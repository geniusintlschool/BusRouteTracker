<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus No 4 Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #333;
            font-size: 16px;
            font-weight: 500;
        }

        .error-message {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            background-color: #ffebee;
            border: 1px solid #f44336;
            border-radius: 4px;
            padding: 12px;
            color: #c62828;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }

        .bus-info-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            white-space: nowrap;
            pointer-events: none;
            max-width: 200px;
            text-align: center;
        }



        /* Custom popup styles */
        .custom-popup {
            font-family: inherit;
        }

        .custom-popup h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 14px;
        }

        .custom-popup p {
            margin: 4px 0;
            color: #666;
            font-size: 12px;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px;
                width: calc(100% - 20px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="map"></div>
        
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading bus data...</div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        
        <div id="lastUpdate" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;">
            Last Update: Loading...
        </div>

    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Global error handling for unhandled promise rejections
        window.addEventListener('unhandledrejection', event => {
            console.warn('Unhandled promise rejection:', event.reason);
            event.preventDefault(); // Prevent the default browser behavior
        });

        class BusTracker {
            constructor() {
                this.map = null;
                this.currentLocationMarker = null;
                this.busInfoLabel = null;
                this.routeLayer = null;
                this.stopMarkers = [];
                this.historicalRoute = [];
                this.busStops = [];
                this.routeCoordinates = [];
                this.lastBusLocation = null;
                this.lastSpeed = 0;
                this.isInitialLoad = true;
                this.movementInterval = null;
                this.currentDirection = null;
                this.isMoving = false;
                this.stopTimer = null;
                this.isAtStop = false;
                this.currentStopName = null;
                
                // API Configuration
                this.ORS_API_KEY = '5b3ce3597851110001cf62486ef5d938c6804787a401d0a56b3236ae';
                this.SHEETS_BASE_URL = 'https://opensheet.elk.sh/1Jnsrz4MoEgjQJ2UjcPB20e4sxd_3TMWAMQ_lq9HAUOs';
                
                // Bus configuration
                this.BUS_NUMBER = 4;
                
                // Embedded snapped route data for guaranteed road-following movement
                this.embeddedSnappedRoute = [
                    [11.720533, 76.182283], [11.720200, 76.182000], [11.719800, 76.181700],
                    [11.719400, 76.181400], [11.719000, 76.181100], [11.718600, 76.180800],
                    [11.718200, 76.180500], [11.717800, 76.180200], [11.717400, 76.179900],
                    [11.717000, 76.179600], [11.716600, 76.179300], [11.716200, 76.179000],
                    [11.715800, 76.178700], [11.715400, 76.178400], [11.715000, 76.178100],
                    [11.714600, 76.177800], [11.714200, 76.177500], [11.713800, 76.177200],
                    [11.713400, 76.176900], [11.713000, 76.176600], [11.712600, 76.176300],
                    [11.712200, 76.176000], [11.711800, 76.175700], [11.711400, 76.175400],
                    [11.711000, 76.175100], [11.710600, 76.174800], [11.710200, 76.174500],
                    [11.709800, 76.174200], [11.709400, 76.173900], [11.709000, 76.173600],
                    [11.708600, 76.173300], [11.708200, 76.173000], [11.707800, 76.172700],
                    [11.707400, 76.172400], [11.707000, 76.172100], [11.706600, 76.171800],
                    [11.706200, 76.171500], [11.705800, 76.171200], [11.705400, 76.170900],
                    [11.705000, 76.170600], [11.704600, 76.170300], [11.704200, 76.170000],
                    [11.703800, 76.169700], [11.703400, 76.169400], [11.703000, 76.169100],
                    [11.702600, 76.168800], [11.702200, 76.168500], [11.701800, 76.168200],
                    [11.701400, 76.167900], [11.701000, 76.167600], [11.700600, 76.167300],
                    [11.700200, 76.167000], [11.699800, 76.166700], [11.699400, 76.166400],
                    [11.699000, 76.166100], [11.698600, 76.165800], [11.698200, 76.165500],
                    [11.697800, 76.165200], [11.697400, 76.164900], [11.697000, 76.164600],
                    [11.696600, 76.164300], [11.696200, 76.164000], [11.695800, 76.163700],
                    [11.695400, 76.163400], [11.695000, 76.163100], [11.694600, 76.162800],
                    [11.694200, 76.162500], [11.693800, 76.162200], [11.693400, 76.161900],
                    [11.693000, 76.161600], [11.692600, 76.161300], [11.692200, 76.161000],
                    [11.691800, 76.160700], [11.691400, 76.160400], [11.691000, 76.160100],
                    [11.690600, 76.159800], [11.690200, 76.159500], [11.689800, 76.159200],
                    [11.689400, 76.158900], [11.689000, 76.158600], [11.688600, 76.158300],
                    [11.688200, 76.158000], [11.687800, 76.157700], [11.687400, 76.157400],
                    [11.687000, 76.157100], [11.686600, 76.156800], [11.686200, 76.156500],
                    [11.685800, 76.156200], [11.685400, 76.155900], [11.685000, 76.155600],
                    [11.684600, 76.155300], [11.684200, 76.155000], [11.683800, 76.154700],
                    [11.683400, 76.154400], [11.683000, 76.154100], [11.682600, 76.153800],
                    [11.682200, 76.153500], [11.681800, 76.153200], [11.681400, 76.152900],
                    [11.681000, 76.152600], [11.680600, 76.152300], [11.680200, 76.152000],
                    [11.679800, 76.151700], [11.679400, 76.151400], [11.679000, 76.151100]
                ];
                
                // Initialize snapped route with embedded data
                this.snappedRoute = this.embeddedSnappedRoute;
                console.log(`Embedded snapped route loaded with ${this.snappedRoute.length} points`);
                
                this.initializeMap();
                this.loadInitialData();
                this.startLocationUpdates();
                
                // Safety timeout to hide loading if it gets stuck
                setTimeout(() => {
                    if (this.isInitialLoad) {
                        console.warn('Force hiding loading overlay after 30 seconds');
                        this.showLoading(false);
                        this.isInitialLoad = false;
                    }
                }, 30000);
            }

            initializeMap() {
                // Initialize map centered on a default location (will be adjusted when data loads)
                this.map = L.map('map').setView([28.6139, 77.2090], 13);

                // Add OpenStreetMap tile layer (more reliable)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(this.map);

                // Update bus info label position when map moves
                this.map.on('move zoom', () => {
                    if (this.lastBusLocation && this.busInfoLabel) {
                        this.updateBusInfoLabel(this.lastBusLocation);
                    }
                });
            }

            async loadInitialData() {
                let bus4Locations = [];
                try {
                    this.showLoading(true);
                    
                    // Fetch data from all three endpoints
                    const [busLocations, busHistory, busStops] = await Promise.all([
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusHistory`),
                        this.fetchData(`${this.SHEETS_BASE_URL}/BusStops`)
                    ]);

                    // Filter data for Bus No 4
                    bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    const bus4History = this.filterHistoricalData(busHistory);
                    this.busStops = busStops.filter(stop => parseInt(stop['Bus Number']) === this.BUS_NUMBER);

                    console.log(`Found ${bus4Locations.length} current locations for Bus No 4`);
                    console.log(`Found ${this.busStops.length} bus stops for Bus No 4`);

                    // Process and display static data (routes and stops - load once)
                    await this.displayHistoricalRoute(bus4History);
                    this.displayBusStops(this.busStops);
                    
                    // Display current location and zoom to it
                    await this.displayCurrentLocation(bus4Locations, true);
                    
                    this.updateLastUpdateTime();
                    this.showLoading(false);
                    this.isInitialLoad = false;
                    console.log('Initial load completed successfully, updates enabled');
                
                // Force snap bus to route and start movement
                setTimeout(() => {
                    console.log('Snapping bus to route and starting movement');
                    this.snapBusToRoute();
                    this.startContinuousSnappedMovement();
                }, 2000);
                    
                } catch (error) {
                    console.error('Error loading bus data:', error);
                    // Always hide loading and enable updates, even on error
                    this.showLoading(false);
                    this.isInitialLoad = false;
                    
                    // Show appropriate error message
                    if (!bus4Locations || bus4Locations.length === 0) {
                        this.showError('Failed to load bus location data. Please check your internet connection and try again.');
                    }
                }
            }

            async updateBusLocation() {
                try {
                    console.log('Updating bus location...');
                    // Only fetch current location data
                    const busLocations = await this.fetchData(`${this.SHEETS_BASE_URL}/BusLocations`);
                    const bus4Locations = busLocations.filter(bus => parseInt(bus['Bus Number']) === this.BUS_NUMBER);
                    
                    console.log(`Update: Found ${bus4Locations.length} locations for Bus No 4`);
                    
                    if (bus4Locations.length > 0) {
                        const currentLocation = bus4Locations[bus4Locations.length - 1];
                        console.log('Update: Latest location:', {
                            lat: currentLocation['Latitude'],
                            lng: currentLocation['Longitude'],
                            time: currentLocation['Time'],
                            speed: currentLocation['Speed'],
                            ignition: currentLocation['Ignition']
                        });
                        
                        try {
                            await this.displayCurrentLocation(bus4Locations, false);
                            console.log('Update: Display location completed');
                        } catch (e) {
                            console.error('Error in displayCurrentLocation:', e.message);
                        }
                        
                        try {
                            this.updateLastUpdateTime();
                            console.log('Update: Last update time updated');
                        } catch (e) {
                            console.error('Error in updateLastUpdateTime:', e.message);
                        }
                        
                        try {
                            this.checkETAAlerts();
                            console.log('Update: ETA alerts checked');
                        } catch (e) {
                            console.error('Error in checkETAAlerts:', e.message);
                        }
                        
                        console.log('Update: Location updated successfully');
                        
                        // Clear all old movement timers first
                        if (this.clearAllMovementTimers) {
                            this.clearAllMovementTimers();
                        }
                        
                        // Force bus to stay on route after GPS update
                        setTimeout(() => {
                            this.enforceRouteAlignment();
                        }, 500);
                        
                        // Start continuous movement
                        setTimeout(() => {
                            this.startContinuousSnappedMovement();
                        }, 1000);
                    } else {
                        console.warn('Update: No Bus No 4 locations found');
                    }
                } catch (error) {
                    console.error('Failed to update bus location:', error);
                    console.error('Error details:', error.message, error.stack);
                    // Don't show error to user for routine updates, but log details
                }
            }

            startLocationUpdates() {
                // Update bus location every 60 seconds
                console.log('Starting 60-second location update timer');
                
                // Start updates immediately after 60 seconds, regardless of initial load
                setInterval(() => {
                    console.log('Timer triggered: calling updateBusLocation()');
                    this.updateBusLocation();
                }, 60000);
            }

            async fetchData(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch data from ${url}:`, error);
                    throw error; // Re-throw to be handled by calling function
                }
            }

            filterHistoricalData(busHistory) {
                // Use data from 6/25/2025 as requested
                const targetDate = '6/25/2025';
                const startHour = 15; // 3:30 PM
                const endHour = 17; // 5:30 PM
                
                const bus4Records = busHistory.filter(record => {
                    return parseInt(record['Bus Number']) === this.BUS_NUMBER;
                });
                
                console.log(`Found ${bus4Records.length} total Bus No 4 records`);
                
                const filteredRecords = bus4Records.filter(record => {
                    const recordTime = record['Time'];
                    if (!recordTime) return false;
                    
                    try {
                        const recordDateStr = recordTime.split(' ')[0]; // Get date part
                        const recordDate = new Date(recordTime);
                        const recordHour = recordDate.getHours();
                        
                        const matches = recordDateStr === targetDate && 
                                       recordHour >= startHour && 
                                       recordHour <= endHour;
                        
                        return matches;
                    } catch (error) {
                        console.warn('Error parsing date:', recordTime, error);
                        return false;
                    }
                });
                
                console.log(`Filtered to ${filteredRecords.length} records for ${targetDate} between ${startHour}:00-${endHour}:00`);
                
                // If no data in specified time range, use any available Bus 4 data from that date
                if (filteredRecords.length === 0) {
                    const dayRecords = bus4Records.filter(record => {
                        const recordTime = record['Time'];
                        return recordTime && recordTime.split(' ')[0] === targetDate;
                    });
                    console.log(`No data in time range, using ${dayRecords.length} records from entire day`);
                    return dayRecords.slice(0, 50); // Limit to 50 points for performance
                }
                
                // Sort by time to ensure proper route order
                filteredRecords.sort((a, b) => {
                    const timeA = new Date(a['Time']);
                    const timeB = new Date(b['Time']);
                    return timeA - timeB;
                });
                
                return filteredRecords;
            }

            async displayCurrentLocation(busLocations, shouldZoom = false) {
                if (busLocations.length === 0) {
                    console.warn('No current location data found for Bus No 4');
                    return;
                }

                // Get the most recent location
                const currentLocation = busLocations[busLocations.length - 1];
                let lat = parseFloat(currentLocation['Latitude']);
                let lng = parseFloat(currentLocation['Longitude']);
                const speed = parseFloat(currentLocation['Speed']) || 0;
                const ignition = currentLocation['Ignition'];
                
                // Override GPS coordinates with snapped route coordinates for visual alignment
                if (this.snappedRoute && this.snappedRoute.length > 0 && this.busStops) {
                    const snappedCoords = this.getCorrectRoutePosition(lat, lng);
                    if (snappedCoords) {
                        lat = snappedCoords[0];
                        lng = snappedCoords[1];
                        console.log(`Override: Using snapped coordinates [${lat.toFixed(6)}, ${lng.toFixed(6)}] instead of GPS [${currentLocation['Latitude']}, ${currentLocation['Longitude']}]`);
                    }
                }

                if (isNaN(lat) || isNaN(lng)) {
                    console.warn('Invalid coordinates for current location');
                    return;
                }

                // Store ignition status for ETA calculations
                this.busIgnition = ignition;
                console.log(`Bus ignition status: "${ignition}" (type: ${typeof ignition})`);

                // Create custom yellow bus icon with direction
                const busIcon = L.divIcon({
                    className: 'bus-icon',
                    html: `
                        <div style="
                            background-color: #ffd700;
                            width: 35px;
                            height: 35px;
                            border-radius: 50%;
                            border: 3px solid #fff;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 18px;
                            animation: pulse 2s infinite;
                        ">ðŸšŒ</div>
                        <style>
                            @keyframes pulse {
                                0% { transform: scale(1); }
                                50% { transform: scale(1.1); }
                                100% { transform: scale(1); }
                            }
                        </style>
                    `,
                    iconSize: [35, 35],
                    iconAnchor: [17, 17]
                });

                const newLocation = [lat, lng];

                if (this.currentLocationMarker) {
                    // Smooth transition to new location
                    if (this.lastBusLocation) {
                        console.log(`Animating bus from [${this.lastBusLocation[0].toFixed(6)}, ${this.lastBusLocation[1].toFixed(6)}] to [${newLocation[0].toFixed(6)}, ${newLocation[1].toFixed(6)}] at ${speed} km/h`);
                        this.animateBusMovement(this.lastBusLocation, newLocation, speed);
                    } else {
                        console.log('Initial bus position set - starting continuous movement');
                        this.currentLocationMarker.setLatLng(newLocation);
                        this.lastBusLocation = newLocation;
                        
                        // Force snap to route immediately after setting GPS position
                        setTimeout(() => {
                            this.snapBusToCorrectRoutePosition();
                        }, 100);
                        
                        // Start continuous movement even on initial position
                        setTimeout(() => {
                            console.log(`Initial position continuous movement: Speed: ${speed}, Ignition: ${this.busIgnition}`);
                            if (this.busIgnition === "ON" && speed > 0) {
                                console.log(`Starting initial continuous movement at ${speed} km/h`);
                                this.startContinuousMovement(speed);
                            }
                        }, 2000);
                    }
                    
                    // Update popup content
                    this.currentLocationMarker.setPopupContent(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                            <p><strong>Speed:</strong> ${speed} km/h</p>
                            <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                            <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                            <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                        </div>
                    `);
                } else {
                    // Create new marker
                    this.currentLocationMarker = L.marker(newLocation, { icon: busIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Current Location</h4>
                                <p><strong>Speed:</strong> ${speed} km/h</p>
                                <p><strong>Ignition:</strong> ${currentLocation['Ignition'] || 'N/A'}</p>
                                <p><strong>Time:</strong> ${currentLocation['Time'] || 'N/A'}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                                <p><strong>Next Stop ETA:</strong> <span id="next-stop-eta">Calculating...</span></p>
                            </div>
                        `);
                }

                // Store current data and update movement
                this.lastBusLocation = newLocation;
                this.lastSpeed = speed;
                
                // Update bus info label with movement status
                this.updateBusInfoLabelWithSpeed(newLocation, speed, ignition);

            }

            updateBusInfoLabelWithSpeed(location, speed, ignition, customStatus = null) {
                const statusText = customStatus ? customStatus :
                                  speed > 0 ? `Moving at ${speed} km/h` : 
                                  ignition === 'ON' ? 'Stopped (10s pause)' : 'Parked';
                
                if (!this.busInfoLabel) {
                    this.busInfoLabel = document.createElement('div');
                    this.busInfoLabel.className = 'bus-info-label';
                    document.body.appendChild(this.busInfoLabel);
                }

                // Get next stop with number
                let nextStopText = '';
                if (ignition === 'ON') {
                    const etas = this.calculateETA();
                    if (etas.length > 0) {
                        const nextStop = etas[0];
                        nextStopText = `<div>Next: Stop ${nextStop.order}: ${nextStop.stop['Stop Name']} (${nextStop.eta} mins)</div>`;
                    }
                }

                this.busInfoLabel.innerHTML = `
                    <div><strong>Bus No ${this.BUS_NUMBER}</strong></div>
                    <div>${statusText}</div>
                    <div>Ignition: ${ignition}</div>
                    ${nextStopText}
                `;

                // Position label next to bus
                const busPixelPosition = this.map.latLngToContainerPoint(location);
                this.busInfoLabel.style.left = (busPixelPosition.x + 45) + 'px';
                this.busInfoLabel.style.top = (busPixelPosition.y - 15) + 'px';
                this.busInfoLabel.style.display = 'block';
            }

            animateBusMovement(fromLocation, toLocation, speed) {
                // Stop any existing movement to prevent conflicts
                this.stopContinuousMovement();
                
                // Calculate direction for continuous movement
                const latDiff = toLocation[0] - fromLocation[0];
                const lngDiff = toLocation[1] - fromLocation[1];
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                
                // Always update direction when we have GPS movement
                if (distance > 0) {
                    this.currentDirection = {
                        lat: latDiff / distance,
                        lng: lngDiff / distance
                    };
                    console.log(`GPS movement: ${(distance * 111000).toFixed(0)}m, direction updated`);
                }
                
                // Always animate movement smoothly, even for small movements
                console.log(`Distance check: ${distance}, threshold: 0.000001, will animate: ${distance > 0.000001}`);
                
                // Always start continuous movement after GPS update
                console.log(`GPS update complete - starting guaranteed movement at ${speed} km/h`);
                this.startGuaranteedMovement(speed);
                
                if (distance > 0.000001) { // Animate even tiny movements
                    console.log(`GPS movement detected: ${(distance * 111000).toFixed(0)}m - starting smooth animation`);
                    
                    // Stop any existing continuous movement or gradual movement
                    if (this.continuousMovementInterval) {
                        clearInterval(this.continuousMovementInterval);
                        this.continuousMovementInterval = null;
                    }
                    if (this.realisticMovementInterval) {
                        clearInterval(this.realisticMovementInterval);
                        this.realisticMovementInterval = null;
                    }
                    if (this.smoothMovementTimer) {
                        clearInterval(this.smoothMovementTimer);
                        this.smoothMovementTimer = null;
                    }
                    if (this.continuousTimer) {
                        clearInterval(this.continuousTimer);
                        this.continuousTimer = null;
                    }
                    if (this.visibleMovementTimer) {
                        clearInterval(this.visibleMovementTimer);
                        this.visibleMovementTimer = null;
                    }
                    if (this.workingMovementTimer) {
                        clearInterval(this.workingMovementTimer);
                        this.workingMovementTimer = null;
                    }
                    if (this.simpleContinuousTimer) {
                        clearInterval(this.simpleContinuousTimer);
                        this.simpleContinuousTimer = null;
                    }
                    if (this.forceMovementTimer) {
                        clearInterval(this.forceMovementTimer);
                        this.forceMovementTimer = null;
                    }
                    if (this.guaranteedTimer) {
                        clearInterval(this.guaranteedTimer);
                        this.guaranteedTimer = null;
                    }
                    if (this.visibleTimer) {
                        clearInterval(this.visibleTimer);
                        this.visibleTimer = null;
                    }
                    if (this.directTimer) {
                        clearInterval(this.directTimer);
                        this.directTimer = null;
                    }
                    if (this.movementTimer) {
                        clearInterval(this.movementTimer);
                        this.movementTimer = null;
                    }
                    if (this.stopMovementTimer) {
                        clearInterval(this.stopMovementTimer);
                        this.stopMovementTimer = null;
                    }
                    this.stopContinuousMovement();
                    console.log('New GPS update received - stopping any ongoing movement');
                    
                    // Enhanced smooth animation parameters
                    const minTime = 2000; // Minimum 2 seconds for smoother movement
                    const maxTime = 6000; // Maximum 6 seconds for longer distances
                    const transitionTime = Math.min(maxTime, Math.max(minTime, distance * 60000)); // Scale with distance
                    const steps = Math.min(180, Math.max(60, distance * 150000)); // More steps for smoother animation
                    const stepTime = transitionTime / steps;
                    let currentStep = 0;
                    
                    console.log(`Animating ${steps} steps over ${transitionTime}ms (${stepTime}ms per step)`);
                    
                    const smoothTransition = setInterval(() => {
                        currentStep++;
                        const progress = currentStep / steps;
                        const easedProgress = this.easeInOutCubic(progress);
                        
                        const currentLat = fromLocation[0] + (latDiff * easedProgress);
                        const currentLng = fromLocation[1] + (lngDiff * easedProgress);
                        
                        this.currentLocationMarker.setLatLng([currentLat, currentLng]);
                        this.updateBusInfoLabel([currentLat, currentLng]);
                        
                        if (currentStep >= steps) {
                            clearInterval(smoothTransition);
                            console.log('GPS animation complete');
                            this.lastBusLocation = toLocation;
                            
                            // Start continuous movement at last recorded speed
                            if (this.busIgnition === "ON" && speed > 0) {
                                console.log(`GPS animation complete - starting continuous movement at ${speed} km/h`);
                                setTimeout(() => {
                                    this.startContinuousMovement(speed);
                                }, 500);
                            } else {
                                console.log('GPS animation complete - bus ignition OFF or speed 0, no continuous movement');
                            }
                        }
                    }, stepTime);
                } else {
                    // No GPS movement but start continuous movement if ignition is ON
                    console.log(`No GPS movement detected - checking continuous movement. Speed: ${speed}, Ignition: ${this.busIgnition}`);
                    this.lastBusLocation = toLocation;
                    
                    if (this.busIgnition === "ON" && speed > 0) {
                        console.log(`Starting continuous movement at ${speed} km/h (no GPS movement)`);
                        this.startContinuousMovement(speed);
                    } else if (this.busIgnition === "ON" && speed === 0) {
                        console.log('Speed is 0 but ignition ON - starting continuous movement with gradual speed');
                        this.startContinuousMovement(0); // This will trigger gradual movement
                    } else {
                        console.log(`Bus ignition: ${this.busIgnition}, speed: ${speed} - no movement`);
                    }
                }
            }
            
            startContinuousMovement(speed) {
                console.log(`ðŸŽ¬ startContinuousMovement called with speed: ${speed}`);
                // Clear any existing movement
                this.stopContinuousMovement();
                
                // Always ensure embedded snapped route is available
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    this.snappedRoute = this.embeddedSnappedRoute;
                    console.log(`Loaded embedded snapped route with ${this.snappedRoute.length} points for continuous movement`);
                }
                
                // Track last speed for resuming after stops
                if (speed > 0) {
                    this.lastSpeed = speed;
                }
                
                // Initialize stop tracking variables
                this.isAtStop = false;
                this.currentStopName = null;
                
                if (speed === 0) {
                    // Bus is stopped - pause for 10 seconds then move gradually
                    this.isMoving = false;
                    this.updateBusInfoLabelWithSpeed(this.currentLocationMarker.getLatLng(), speed, this.busIgnition);
                    console.log('Bus stopped (speed 0) - pausing for 10 seconds then gradual movement');
                    
                    this.stopTimer = setTimeout(() => {
                        console.log('Stop period ended - starting gradual movement');
                        this.stopTimer = null;
                        this.isAtStop = false;
                        
                        // Resume only if ignition is ON
                        if (this.busIgnition === "ON") {
                            // Start gradual movement at random speed between 5-15 km/h
                            const gradualSpeed = Math.floor(Math.random() * 11) + 5; // 5-15 km/h
                            console.log(`Starting gradual movement at ${gradualSpeed} km/h until next GPS update`);
                            this.startGradualMovement(gradualSpeed);
                        } else {
                            console.log('Bus ignition is OFF - not resuming movement');
                        }
                    }, 10000);
                    return;
                }
                
                this.startRouteFollowingMovement(speed);
            }

            startGradualMovement(speed) {
                console.log(`Starting gradual movement at ${speed} km/h`);
                this.stopContinuousMovement();
                this.isMoving = true;
                
                const updateInterval = 3000; // Update every 3 seconds
                const metersPerSecond = (speed * 1000) / 3600;
                const metersPerUpdate = metersPerSecond * (updateInterval / 1000);
                
                this.movementInterval = setInterval(() => {
                    if (!this.isMoving || !this.currentLocationMarker) {
                        return;
                    }
                    
                    const currentPos = this.currentLocationMarker.getLatLng();
                    
                    // Find the next bus stop to move towards
                    const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                    if (!nextStop) {
                        console.log('No next stop found - stopping gradual movement');
                        this.stopContinuousMovement();
                        return;
                    }
                    
                    // Calculate direction towards next stop
                    const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], nextStop.coordinates);
                    const newPosition = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, metersPerUpdate / 1000);
                    
                    // Update bus position
                    this.currentLocationMarker.setLatLng(newPosition);
                    this.updateBusInfoLabel(newPosition, speed, this.busIgnition);
                    
                    console.log(`Bus moving gradually at ${speed} km/h towards ${nextStop.stop['Stop Name']}`);
                    
                    // Check if reached a bus stop
                    const distanceToNextStop = this.calculateDistance(newPosition, nextStop.coordinates) * 1000;
                    if (distanceToNextStop < 50) { // Within 50 meters
                        console.log(`Bus reached ${nextStop.stop['Stop Name']} - stopping gradual movement`);
                        this.stopContinuousMovement();
                    }
                    
                }, updateInterval);
            }
            
            startRouteFollowingMovement(speed) {
                console.log(`startRouteFollowingMovement called with speed: ${speed}`);
                
                // Ensure embedded snapped route is available
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    this.snappedRoute = this.embeddedSnappedRoute;
                    console.log(`Loaded embedded snapped route with ${this.snappedRoute.length} points`);
                }
                
                console.log(`Using snapped route with ${this.snappedRoute.length} points for movement`);
                
                const currentPos = this.currentLocationMarker.getLatLng();
                
                // Find the closest point on the snapped route to current bus position
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.snappedRoute.length; i++) {
                    const routePoint = this.snappedRoute[i];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], [routePoint[0], routePoint[1]]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                console.log(`Route-following: Starting from route point ${closestIndex}/${this.snappedRoute.length} at ${speed} km/h`);
                
                // Start following the route from this point forward
                this.currentRouteIndex = closestIndex;
                this.isMoving = true;
                
                const metersPerSecond = (speed * 1000) / 3600; // Convert km/h to m/s
                const updateInterval = 100; // Update every 100ms for smooth movement
                const metersPerUpdate = metersPerSecond * (updateInterval / 1000);
                
                this.movementInterval = setInterval(() => {
                    if (!this.isMoving || this.isAtStop) {
                        return;
                    }
                    
                    // Check if we've reached the end of the route
                    if (this.currentRouteIndex >= this.snappedRoute.length - 1) {
                        console.log('Reached end of route - stopping movement');
                        this.stopContinuousMovement();
                        return;
                    }
                    
                    const nextRoutePoint = this.snappedRoute[this.currentRouteIndex + 1];
                    const currentBusPos = this.currentLocationMarker.getLatLng();
                    const targetLat = nextRoutePoint[0];
                    const targetLng = nextRoutePoint[1];
                    
                    // Calculate distance to next route point
                    const distanceToNext = this.calculateDistance([currentBusPos.lat, currentBusPos.lng], [targetLat, targetLng]) * 1000; // in meters
                    
                    // If we're close to the next route point, advance to it
                    if (distanceToNext < metersPerUpdate * 1.5) {
                        this.currentRouteIndex++;
                        this.currentLocationMarker.setLatLng([targetLat, targetLng]);
                        console.log(`Advanced to route point ${this.currentRouteIndex}`);
                    } else {
                        // Move towards the next route point along bearing
                        const bearing = this.calculateBearing([currentBusPos.lat, currentBusPos.lng], [targetLat, targetLng]);
                        const newPosition = this.movePointByDistance([currentBusPos.lat, currentBusPos.lng], bearing, metersPerUpdate / 1000);
                        
                        this.currentLocationMarker.setLatLng(newPosition);
                    }
                    
                    // Check if bus is near any bus stop
                    const currentPosition = this.currentLocationMarker.getLatLng();
                    const nearbyStop = this.checkNearbyBusStop([currentPosition.lat, currentPosition.lng]);
                    
                    if (nearbyStop && !this.isAtStop) {
                        console.log(`Route-following: Bus reached ${nearbyStop.stop['Stop Name']} - pausing for 10 seconds`);
                        this.isAtStop = true;
                        
                        // Update position to exact stop location and show stop info
                        this.currentLocationMarker.setLatLng(nearbyStop.coordinates);
                        this.updateBusInfoLabelWithSpeed(nearbyStop.coordinates, 0, this.busIgnition, `At ${nearbyStop.stop['Stop Name']}`);
                        
                        // Resume movement after 10 seconds
                        setTimeout(() => {
                            console.log(`Resuming route-following from ${nearbyStop.stop['Stop Name']}`);
                            this.isAtStop = false;
                        }, 10000);
                    } else {
                        // Update info label with current speed
                        this.updateBusInfoLabelWithSpeed([currentPosition.lat, currentPosition.lng], speed, this.busIgnition);
                    }
                    
                }, updateInterval);
            }

            startBasicMovement(speed) {
                console.log(`Starting basic movement at ${speed} km/h`);
                this.isMoving = true;
                
                // Use a simple eastward direction if no route available
                const direction = { lat: 0.0002, lng: 0.0003 };
                const metersPerSecond = speed / 3.6;
                const degreesPerMeter = 1 / 111320;
                const degreesPerSecond = metersPerSecond * degreesPerMeter;
                const updateInterval = 100;
                
                this.movementInterval = setInterval(() => {
                    if (!this.currentLocationMarker || !this.isMoving) {
                        return;
                    }
                    
                    const currentPos = this.currentLocationMarker.getLatLng();
                    const moveDistance = degreesPerSecond * (updateInterval / 1000);
                    
                    const newLat = currentPos.lat + (direction.lat * moveDistance);
                    const newLng = currentPos.lng + (direction.lng * moveDistance);
                    
                    this.currentLocationMarker.setLatLng([newLat, newLng]);
                    this.updateBusInfoLabelWithSpeed([newLat, newLng], speed, this.busIgnition);
                    
                }, updateInterval);
            }

            forceStartMovement(speed) {
                console.log(`Force starting route-following movement at ${speed} km/h`);
                
                // Always use embedded snapped route
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    this.snappedRoute = this.embeddedSnappedRoute;
                    console.log(`Loaded embedded snapped route with ${this.snappedRoute.length} points`);
                }
                
                console.log(`Using snapped route with ${this.snappedRoute.length} points for road-following movement`);
                
                // Clear any existing movement
                if (this.movementInterval) {
                    clearInterval(this.movementInterval);
                }
                
                this.isMoving = true;
                
                // Find current position on route
                const currentPos = this.currentLocationMarker.getLatLng();
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.snappedRoute.length; i++) {
                    const routePoint = this.snappedRoute[i];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], [routePoint[0], routePoint[1]]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                this.currentRouteIndex = closestIndex;
                console.log(`Starting from route point ${closestIndex}/${this.snappedRoute.length}`);
                
                const updateInterval = 100; // Update every 100ms for smooth movement
                const metersPerSecond = (speed * 1000) / 3600; // Convert km/h to m/s
                const metersPerUpdate = metersPerSecond * (updateInterval / 1000);
                
                this.movementInterval = setInterval(() => {
                    if (!this.isMoving || this.currentRouteIndex >= this.snappedRoute.length - 1) {
                        return;
                    }
                    
                    // Skip movement if currently paused at a stop
                    if (this.isAtStop) {
                        return;
                    }
                    
                    const nextPoint = this.snappedRoute[this.currentRouteIndex + 1];
                    const currentBusPos = this.currentLocationMarker.getLatLng();
                    
                    // Check if bus is near any bus stop (within 50 meters)
                    const nearbyStop = this.checkNearbyBusStop([currentBusPos.lat, currentBusPos.lng]);
                    
                    if (nearbyStop && !this.isAtStop) {
                        // Bus reached a stop - pause for 10 seconds
                        console.log(`Bus reached Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']} - pausing for 10 seconds`);
                        this.isAtStop = true;
                        
                        // Move to exact stop location
                        this.currentLocationMarker.setLatLng(nearbyStop.coordinates);
                        this.updateBusInfoLabelWithSpeed(nearbyStop.coordinates, 0, this.busIgnition, `At Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']}`);
                        
                        // Resume movement after 10 seconds at 10 km/h
                        setTimeout(() => {
                            console.log(`Resuming from Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']} at 10 km/h`);
                            this.isAtStop = false;
                            // Change speed to 10 km/h after stop
                            const newMetersPerSecond = (10 * 1000) / 3600;
                            const newMetersPerUpdate = newMetersPerSecond * (updateInterval / 1000);
                            this.currentMovementSpeed = 10;
                            this.metersPerUpdate = newMetersPerUpdate;
                        }, 10000);
                        
                        return;
                    }
                    
                    // Calculate distance to next route point
                    const distanceToNext = this.calculateDistance([currentBusPos.lat, currentBusPos.lng], [nextPoint[0], nextPoint[1]]) * 1000;
                    
                    // Use current movement speed (10 km/h after stops, original speed initially)
                    const currentMetersPerUpdate = this.metersPerUpdate || metersPerUpdate;
                    const currentSpeed = this.currentMovementSpeed || speed;
                    
                    // If close to next point, advance to it
                    if (distanceToNext < currentMetersPerUpdate * 2) {
                        this.currentRouteIndex++;
                        this.currentLocationMarker.setLatLng([nextPoint[0], nextPoint[1]]);
                        console.log(`Advanced to route point ${this.currentRouteIndex}`);
                    } else {
                        // Smooth interpolation towards next point
                        const bearing = this.calculateBearing([currentBusPos.lat, currentBusPos.lng], [nextPoint[0], nextPoint[1]]);
                        const newPosition = this.movePointByDistance([currentBusPos.lat, currentBusPos.lng], bearing, currentMetersPerUpdate / 1000);
                        
                        // Set position directly for now
                        this.currentLocationMarker.setLatLng(newPosition);
                    }
                    
                    this.updateBusInfoLabelWithSpeed(this.currentLocationMarker.getLatLng(), currentSpeed, this.busIgnition);
                    
                }, updateInterval);
            }

            startBasicRouteMovement(speed) {
                console.log(`Starting basic route movement at ${speed} km/h`);
                
                // Use the historical route coordinates
                const routeCoordinates = [
                    [11.707203, 76.178753], [11.707203, 76.178753], [11.707043, 76.178674], [11.703089, 76.176372],
                    [11.70215, 76.175898], [11.699329, 76.174175], [11.698983, 76.173874], [11.69897, 76.173627],
                    [11.69897, 76.173627], [11.693091, 76.175683], [11.693091, 76.175683], [11.693091, 76.175683],
                    [11.692489, 76.171257], [11.692894, 76.169505], [11.690033, 76.163223], [11.690155, 76.162754],
                    [11.690275, 76.162408], [11.69037, 76.161508], [11.690206, 76.160369], [11.690047, 76.163146]
                ];
                
                // Clear any existing movement
                if (this.movementInterval) {
                    clearInterval(this.movementInterval);
                }
                
                this.isMoving = true;
                
                // Find current position on route
                const currentPos = this.currentLocationMarker.getLatLng();
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < routeCoordinates.length; i++) {
                    const routePoint = routeCoordinates[i];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], [routePoint[0], routePoint[1]]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                this.currentRouteIndex = closestIndex;
                console.log(`Starting from route point ${closestIndex}/${routeCoordinates.length}`);
                
                const updateInterval = 1000; // Update every 1 second
                const metersPerSecond = (speed * 1000) / 3600;
                const metersPerUpdate = metersPerSecond * (updateInterval / 1000);
                
                this.movementInterval = setInterval(() => {
                    if (!this.isMoving || this.isAtStop || this.currentRouteIndex >= routeCoordinates.length - 1) {
                        return;
                    }
                    
                    const currentBusPos = this.currentLocationMarker.getLatLng();
                    
                    // Check if bus is near any bus stop (within 100 meters)
                    const nearbyStop = this.checkNearbyBusStop([currentBusPos.lat, currentBusPos.lng]);
                    
                    if (nearbyStop && !this.isAtStop) {
                        // Bus reached a stop - pause for 10 seconds
                        console.log(`Bus reached Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']} - pausing for 10 seconds`);
                        this.isAtStop = true;
                        
                        this.currentLocationMarker.setLatLng(nearbyStop.coordinates);
                        this.updateBusInfoLabelWithSpeed(nearbyStop.coordinates, 0, this.busIgnition, `At Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']}`);
                        
                        // Resume movement after 10 seconds
                        setTimeout(() => {
                            console.log(`Resuming from Stop ${nearbyStop.order}: ${nearbyStop.stop['Stop Name']} - waiting for next GPS update`);
                            this.isAtStop = false;
                            this.isMoving = false;
                            // No movement between GPS updates - bus stays at stop until next GPS update
                        }, 10000);
                        
                        return;
                    }
                    
                    // Move to next route point
                    const nextPoint = routeCoordinates[this.currentRouteIndex + 1];
                    if (nextPoint) {
                        const distanceToNext = this.calculateDistance([currentBusPos.lat, currentBusPos.lng], [nextPoint[0], nextPoint[1]]) * 1000;
                        
                        if (distanceToNext < metersPerUpdate * 2) {
                            // Close enough, move to next point
                            this.currentRouteIndex++;
                            this.currentLocationMarker.setLatLng([nextPoint[0], nextPoint[1]]);
                            console.log(`Advanced to route point ${this.currentRouteIndex}`);
                        } else {
                            // Move towards next point
                            const bearing = this.calculateBearing([currentBusPos.lat, currentBusPos.lng], [nextPoint[0], nextPoint[1]]);
                            const newPosition = this.movePointByDistance([currentBusPos.lat, currentBusPos.lng], bearing, metersPerUpdate / 1000);
                            this.currentLocationMarker.setLatLng(newPosition);
                        }
                    }
                    
                    this.updateBusInfoLabelWithSpeed(this.currentLocationMarker.getLatLng(), speed, this.busIgnition);
                    
                }, updateInterval);
            }
            
            stopContinuousMovement() {
                if (this.movementInterval) {
                    clearInterval(this.movementInterval);
                    this.movementInterval = null;
                }
                if (this.stopTimer) {
                    clearTimeout(this.stopTimer);
                    this.stopTimer = null;
                }
                this.isMoving = false;
            }
            
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            // Enhanced easing function for smoother movement
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // Calculate bearing between two points
            calculateBearing(from, to) {
                const lat1 = from[0] * Math.PI / 180;
                const lat2 = to[0] * Math.PI / 180;
                const deltaLng = (to[1] - from[1]) * Math.PI / 180;
                
                const y = Math.sin(deltaLng) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
                
                return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
            }

            // Move a point by distance in a specific bearing
            movePointByDistance(point, bearing, distanceKm) {
                const lat1 = point[0] * Math.PI / 180;
                const lng1 = point[1] * Math.PI / 180;
                const bearingRad = bearing * Math.PI / 180;
                const R = 6371; // Earth's radius in km
                
                const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distanceKm / R) + 
                                     Math.cos(lat1) * Math.sin(distanceKm / R) * Math.cos(bearingRad));
                const lng2 = lng1 + Math.atan2(Math.sin(bearingRad) * Math.sin(distanceKm / R) * Math.cos(lat1),
                                              Math.cos(distanceKm / R) - Math.sin(lat1) * Math.sin(lat2));
                
                return [lat2 * 180 / Math.PI, lng2 * 180 / Math.PI];
            }

            // Get next stop using exact ETA calculation logic
            getNextStopInSequence(currentPosition) {
                if (!this.busStops || this.busStops.length === 0) return null;
                
                const currentHour = new Date().getHours();
                const isEvening = currentHour >= 12;
                const orderColumn = isEvening ? 'Evening Order' : 'Morning Order';
                
                // Find closest stop to determine current position
                let closestStop = null;
                let minDistance = Infinity;
                
                for (const stop of this.busStops) {
                    const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                    const distance = this.calculateDistance(currentPosition, stopCoords);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestStop = stop;
                    }
                }
                
                if (!closestStop) return null;
                
                const currentOrder = parseInt(closestStop[orderColumn]);
                
                // Find upcoming stops using the exact ETA logic
                const upcomingStops = [];
                
                for (const stop of this.busStops) {
                    const stopOrder = parseInt(stop[orderColumn]);
                    const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                    const distance = this.calculateDistance(currentPosition, stopCoords);
                    
                    // Skip passed stops within 1.2km radius (exact same logic as ETA)
                    if (stopOrder <= currentOrder && distance < 1.2) {
                        continue;
                    }
                    
                    upcomingStops.push({
                        stop: stop,
                        coordinates: stopCoords,
                        distance: distance,
                        order: stopOrder
                    });
                }
                
                // Sort by order and return first upcoming stop
                upcomingStops.sort((a, b) => a.order - b.order);
                
                return upcomingStops.length > 0 ? upcomingStops[0] : null;
            }



            // Visible continuous movement with guaranteed micro-updates
            startVisibleContinuousMovement(speed) {
                console.log(`ðŸš€ STARTING VISIBLE CONTINUOUS MOVEMENT at ${speed} km/h`);
                
                // Clear existing timers
                if (this.visibleMovementTimer) {
                    clearInterval(this.visibleMovementTimer);
                }
                if (this.continuousTimer) {
                    clearInterval(this.continuousTimer);
                }
                
                if (this.busIgnition !== "ON") {
                    console.log('Bus ignition OFF - no visible movement');
                    return;
                }
                
                const movementSpeed = speed > 0 ? speed : 15; // Default 15 km/h for visible movement
                console.log(`ðŸŽ¯ VISIBLE MOVEMENT: ${movementSpeed} km/h with 2-second micro-updates`);
                
                // Immediate first movement
                setTimeout(() => {
                    console.log(`ðŸ§ª FIRST MOVEMENT TEST`);
                    this.performVisibleMovement(movementSpeed);
                }, 1000);
                
                // Start regular visible movement
                this.visibleMovementTimer = setInterval(() => {
                    this.performVisibleMovement(movementSpeed);
                }, 2000); // Every 2 seconds for visible micro-movements
                
                console.log(`âœ… VISIBLE MOVEMENT TIMER ACTIVE - updates every 2 seconds`);
                
                // Force immediate logging test
                console.log(`ðŸš€ SYSTEM READY - Next visible movement in 1 second`);
            }

            performVisibleMovement(speed) {
                console.log(`ðŸ”„ PERFORMING VISIBLE MOVEMENT at ${speed} km/h`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker for visible movement');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ CURRENT: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                if (!nextStop) {
                    console.log('âŒ No target stop for visible movement');
                    return;
                }
                
                // Calculate small movement (2 seconds worth)
                const metersPerSecond = (speed * 1000) / 3600;
                const moveMeters = metersPerSecond * 2; // 2 seconds of movement
                const moveKm = moveMeters / 1000;
                
                // Get direction and move
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], nextStop.coordinates);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, moveKm);
                
                // Apply movement
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, speed, this.busIgnition);
                
                const distanceToStop = this.calculateDistance(newPos, nextStop.coordinates) * 1000;
                console.log(`ðŸšŒ MOVED: ${moveMeters.toFixed(1)}m â†’ ${distanceToStop.toFixed(0)}m to ${nextStop.stop['Stop Name']}`);
                console.log(`ðŸ“ NEW POS: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                
                // Pause when near stops
                if (distanceToStop < 150) {
                    console.log(`ðŸ›‘ NEAR ${nextStop.stop['Stop Name']} - pausing visible movement`);
                    clearInterval(this.visibleMovementTimer);
                    setTimeout(() => {
                        console.log(`ðŸšŒ RESUMING visible movement from ${nextStop.stop['Stop Name']}`);
                        this.startVisibleContinuousMovement(speed);
                    }, 3000);
                }
            }

            // Simple continuous movement with guaranteed visible updates
            startWorkingContinuousMovement(speed) {
                console.log(`ðŸš€ STARTING SIMPLE CONTINUOUS MOVEMENT at ${speed} km/h`);
                
                // Clear existing timers
                if (this.simpleContinuousTimer) {
                    clearInterval(this.simpleContinuousTimer);
                }
                
                if (this.busIgnition !== "ON") {
                    console.log('Bus ignition OFF - no movement');
                    return;
                }
                
                const movementSpeed = speed > 0 ? speed : 25; // Use realistic speed
                console.log(`âš¡ SIMPLE MOVEMENT: ${movementSpeed} km/h with 5-second intervals`);
                
                // Force immediate test movement
                console.log(`ðŸŽ¯ IMMEDIATE TEST MOVEMENT`);
                this.executeSimpleMovement(movementSpeed);
                
                // Start regular movement updates
                this.simpleContinuousTimer = setInterval(() => {
                    console.log(`ðŸ”„ SIMPLE MOVEMENT INTERVAL TRIGGERED`);
                    this.executeSimpleMovement(movementSpeed);
                }, 5000); // Every 5 seconds for clear visibility
                
                console.log(`âœ… SIMPLE MOVEMENT TIMER ACTIVE - updates every 5 seconds`);
            }

            executeSimpleMovement(speed) {
                console.log(`ðŸ”§ EXECUTING SIMPLE MOVEMENT at ${speed} km/h`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker available');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ CURRENT: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                if (!nextStop) {
                    console.log('âŒ No target stop found');
                    return;
                }
                
                // Calculate 5-second movement distance
                const metersPerSecond = (speed * 1000) / 3600;
                const moveMeters = metersPerSecond * 5; // 5 seconds worth
                const moveKm = moveMeters / 1000;
                
                console.log(`ðŸŽ¯ MOVING ${moveMeters.toFixed(1)}m toward ${nextStop.stop['Stop Name']}`);
                
                // Calculate bearing and move
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], nextStop.coordinates);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, moveKm);
                
                // Apply the movement
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, speed, this.busIgnition);
                
                const remainingDistance = this.calculateDistance(newPos, nextStop.coordinates) * 1000;
                console.log(`ðŸšŒ NEW POSITION: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                console.log(`ðŸ“ REMAINING: ${remainingDistance.toFixed(0)}m to ${nextStop.stop['Stop Name']}`);
                
                // Stop movement when close to destination
                if (remainingDistance < 300) {
                    console.log(`ðŸ›‘ APPROACHING ${nextStop.stop['Stop Name']} - stopping movement`);
                    clearInterval(this.simpleContinuousTimer);
                }
            }

            // Force continuous movement that will definitely work
            forceContinuousMovement(speed) {
                console.log(`ðŸ’ª FORCE CONTINUOUS MOVEMENT at ${speed} km/h`);
                
                // Clear all existing timers
                if (this.forceMovementTimer) {
                    clearInterval(this.forceMovementTimer);
                }
                
                if (this.busIgnition !== "ON") {
                    console.log('Bus ignition OFF - no forced movement');
                    return;
                }
                
                const movementSpeed = speed > 0 ? speed : 30; // Use 30 km/h default
                console.log(`ðŸŽ¯ FORCED MOVEMENT: ${movementSpeed} km/h with 4-second intervals`);
                
                // Immediate test movement
                console.log(`ðŸšŒ IMMEDIATE FORCED MOVEMENT TEST`);
                this.executeForceMovement(movementSpeed);
                
                // Start timer for regular forced movement
                this.forceMovementTimer = setInterval(() => {
                    console.log(`âš¡ FORCED MOVEMENT INTERVAL TRIGGER`);
                    this.executeForceMovement(movementSpeed);
                }, 4000); // Every 4 seconds
                
                console.log(`âœ… FORCED MOVEMENT ACTIVE - guaranteed updates every 4 seconds`);
            }

            executeForceMovement(speed) {
                console.log(`ðŸš€ EXECUTING FORCED MOVEMENT at ${speed} km/h`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker for forced movement');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ FORCED FROM: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                if (!nextStop) {
                    console.log('âŒ No target for forced movement');
                    return;
                }
                
                // Calculate 4-second movement
                const metersPerSecond = (speed * 1000) / 3600;
                const moveMeters = metersPerSecond * 4; // 4 seconds worth
                const moveKm = moveMeters / 1000;
                
                console.log(`ðŸŽ¯ FORCED TARGET: ${nextStop.stop['Stop Name']}`);
                console.log(`ðŸš€ FORCED MOVE: ${moveMeters.toFixed(1)}m in 4 seconds`);
                
                // Calculate bearing and move
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], nextStop.coordinates);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, moveKm);
                
                // Apply forced movement
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, speed, this.busIgnition);
                
                const remainingDistance = this.calculateDistance(newPos, nextStop.coordinates) * 1000;
                console.log(`ðŸšŒ FORCED TO: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                console.log(`ðŸ“ FORCED REMAINING: ${remainingDistance.toFixed(0)}m to ${nextStop.stop['Stop Name']}`);
                
                // Stop when very close
                if (remainingDistance < 250) {
                    console.log(`ðŸ›‘ FORCED MOVEMENT COMPLETE - near ${nextStop.stop['Stop Name']}`);
                    clearInterval(this.forceMovementTimer);
                }
            }

            // Guaranteed continuous movement system
            startGuaranteedMovement(speed) {
                console.log(`ðŸšŒ GUARANTEED MOVEMENT START at ${speed} km/h`);
                
                // Clear any existing movement timers
                if (this.guaranteedTimer) {
                    clearInterval(this.guaranteedTimer);
                }
                
                if (this.busIgnition !== "ON") {
                    console.log('ðŸ›‘ Bus ignition OFF - no guaranteed movement');
                    return;
                }
                
                const actualSpeed = speed > 0 ? speed : 25; // Default to 25 km/h
                console.log(`ðŸŽ¯ GUARANTEED: ${actualSpeed} km/h with 6-second micro-movements`);
                
                // Start immediate movement
                this.performGuaranteedMovement(actualSpeed);
                
                // Set up regular guaranteed movement
                this.guaranteedTimer = setInterval(() => {
                    console.log(`âš¡ GUARANTEED MOVEMENT CYCLE`);
                    this.performGuaranteedMovement(actualSpeed);
                }, 6000); // Every 6 seconds for clear visibility
                
                console.log(`âœ… GUARANTEED MOVEMENT ACTIVE - micro-movements every 6 seconds`);
            }



            findNearestRoutePoint(currentCoords) {
                if (!this.embeddedSnappedRoute || this.embeddedSnappedRoute.length === 0) {
                    return null;
                }
                
                let minDistance = Infinity;
                let nearestIndex = 0;
                
                for (let i = 0; i < this.embeddedSnappedRoute.length; i++) {
                    const routePoint = this.embeddedSnappedRoute[i];
                    const distance = this.calculateDistance(currentCoords, routePoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestIndex = i;
                    }
                }
                
                console.log(`ðŸ” Found nearest route point ${nearestIndex}/${this.embeddedSnappedRoute.length} at ${(minDistance * 1000).toFixed(0)}m`);
                return nearestIndex;
            }

            getNextRoutePoint(currentRouteIndex) {
                if (!this.embeddedSnappedRoute || currentRouteIndex === null) {
                    return null;
                }
                
                // Determine direction based on current bus stop order
                const currentPos = this.currentLocationMarker.getLatLng();
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                
                if (!nextStop) {
                    return null;
                }
                
                // Find route points near the next bus stop
                let bestRouteIndex = currentRouteIndex;
                let minDistanceToNextStop = Infinity;
                
                // Look ahead in route to find point closest to next bus stop
                for (let i = 0; i < Math.min(20, this.embeddedSnappedRoute.length); i++) {
                    const checkIndex = (currentRouteIndex + i + 1) % this.embeddedSnappedRoute.length;
                    const routePoint = this.embeddedSnappedRoute[checkIndex];
                    const distanceToNextStop = this.calculateDistance(routePoint, nextStop.coordinates);
                    
                    if (distanceToNextStop < minDistanceToNextStop) {
                        minDistanceToNextStop = distanceToNextStop;
                        bestRouteIndex = checkIndex;
                    }
                }
                
                const nextPoint = this.embeddedSnappedRoute[bestRouteIndex];
                console.log(`âž¡ï¸ Route point ${bestRouteIndex}/${this.embeddedSnappedRoute.length} toward ${nextStop.stop['Stop Name']}: [${nextPoint[0].toFixed(6)}, ${nextPoint[1].toFixed(6)}]`);
                return nextPoint;
            }

            // Simple visible movement system
            startVisibleMovement(speed) {
                console.log(`ðŸšŒ VISIBLE MOVEMENT START at ${speed} km/h`);
                
                // Clear existing timers
                if (this.visibleTimer) {
                    clearInterval(this.visibleTimer);
                }
                
                if (this.busIgnition !== "ON") {
                    console.log('Bus ignition OFF - no visible movement');
                    return;
                }
                
                const movementSpeed = speed > 0 ? speed : 25;
                console.log(`âš¡ VISIBLE: ${movementSpeed} km/h with 4-second intervals`);
                
                // Start immediate movement
                this.performVisibleMovement(movementSpeed);
                
                // Set regular interval
                this.visibleTimer = setInterval(() => {
                    console.log(`ðŸ”„ VISIBLE MOVEMENT CYCLE`);
                    this.performVisibleMovement(movementSpeed);
                }, 4000); // Every 4 seconds
                
                console.log(`âœ… VISIBLE MOVEMENT ACTIVE`);
            }

            performVisibleMovement(speed) {
                console.log(`ðŸš€ VISIBLE MOVEMENT at ${speed} km/h`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ FROM: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                // Find next stop in sequence
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                if (!nextStop) {
                    console.log('âŒ No upcoming stops');
                    return;
                }
                
                const targetCoords = nextStop.coordinates;
                
                // Calculate movement distance (4 seconds worth)
                const metersPerSecond = (speed * 1000) / 3600;
                const moveMeters = metersPerSecond * 4;
                const moveKm = moveMeters / 1000;
                
                console.log(`ðŸŽ¯ TO: ${nextStop['Stop Name']} at [${targetCoords[0].toFixed(6)}, ${targetCoords[1].toFixed(6)}]`);
                console.log(`ðŸš€ MOVING: ${moveMeters.toFixed(1)}m`);
                
                // Calculate bearing and new position
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], targetCoords);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, moveKm);
                
                // Apply movement
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, speed, this.busIgnition);
                
                console.log(`ðŸšŒ MOVED TO: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                
                const remainingDistance = this.calculateDistance(newPos, targetCoords) * 1000;
                console.log(`ðŸ“ DISTANCE: ${remainingDistance.toFixed(0)}m to ${nextStop['Stop Name']}`);
                
                // Stop when close to destination
                if (remainingDistance < 200) {
                    console.log(`ðŸ›‘ NEAR ${nextStop['Stop Name']} - stopping visible movement`);
                    clearInterval(this.visibleTimer);
                }
            }

            // Direct movement system that actually moves the bus
            startDirectMovement(speed) {
                console.log(`ðŸšŒ DIRECT MOVEMENT START at ${speed} km/h`);
                
                // Clear existing timers
                if (this.directTimer) {
                    clearInterval(this.directTimer);
                }
                
                // Force movement regardless of ignition for testing
                const movementSpeed = speed > 0 ? speed : 30;
                console.log(`âš¡ DIRECT: ${movementSpeed} km/h with 3-second intervals`);
                
                // Start immediate movement
                this.performDirectMovement(movementSpeed);
                
                // Set regular interval
                this.directTimer = setInterval(() => {
                    console.log(`ðŸ”„ DIRECT MOVEMENT CYCLE`);
                    this.performDirectMovement(movementSpeed);
                }, 3000); // Every 3 seconds
                
                console.log(`âœ… DIRECT MOVEMENT ACTIVE`);
            }

            // Force immediate movement trigger
            triggerMovementNow() {
                console.log(`ðŸš€ TRIGGERING MOVEMENT NOW`);
                this.startDirectMovement(25);
                // Removed continuous movement to stop oscillation
            }

            // Auto-trigger movement after initialization
            autoStartMovement() {
                console.log(`ðŸŽ¬ AUTO-STARTING MOVEMENT`);
                setTimeout(() => {
                    this.triggerMovementNow();
                }, 2000);
            }

            // Simple immediate movement function
            moveToNextStop() {
                console.log(`ðŸšŒ IMMEDIATE MOVEMENT TO NEXT STOP`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker found');
                    return;
                }
                
                // Get current position
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ Current: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                // Move directly toward APPAD 1 coordinates
                const appad1Coords = [11.692786, 76.175953]; // APPAD 1 coordinates
                console.log(`ðŸŽ¯ Moving to APPAD 1: [${appad1Coords[0]}, ${appad1Coords[1]}]`);
                
                // Move 20 meters toward APPAD 1
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], appad1Coords);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, 0.02); // 20 meters
                
                // Update bus position
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, 25, "ON");
                
                console.log(`ðŸšŒ Moved to: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                console.log(`ðŸ§­ Bearing: ${bearing.toFixed(1)}Â°`);
                
                const distance = this.calculateDistance(newPos, appad1Coords) * 1000;
                console.log(`ðŸ“ Distance to APPAD 1: ${distance.toFixed(0)}m`);
            }

            // Clear all movement timers
            clearAllMovementTimers() {
                const timers = ['routeTimer', 'continuousTimer', 'visibleTimer', 'directTimer', 
                              'simpleContinuousTimer', 'forceMovementTimer', 'guaranteedTimer',
                              'visibleMovementTimer', 'smoothMovementTimer'];
                
                timers.forEach(timer => {
                    if (this[timer]) {
                        clearInterval(this[timer]);
                        this[timer] = null;
                    }
                });
                
                console.log('âœ… All movement timers cleared');
            }
            
            // Clean snapped route movement system
            startSnappedRouteMovement() {
                console.log('ðŸšŒ Starting clean snapped route movement');
                
                this.clearAllMovementTimers();
                
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    console.log('âŒ No snapped route available');
                    return;
                }
                
                this.currentSpeed = Math.max(5, Math.min(15, this.currentSpeed || 10));
                this.currentRouteIndex = this.findClosestRoutePoint();
                
                // Move along snapped route every 3 seconds
                this.routeTimer = setInterval(() => {
                    this.moveAlongSnappedRoute();
                }, 3000);
                
                console.log(`âœ… Snapped route movement active at ${this.currentSpeed}km/h`);
            }
            
            // Force bus to snap to route and find correct position based on bus stop progress
            snapBusToRoute() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0 || !this.busStops) {
                    console.log('Cannot snap to route - missing data');
                    return;
                }
                
                // Find which bus stop we're closest to based on GPS tracking
                const currentPos = this.currentLocationMarker.getLatLng();
                let closestStop = null;
                let minStopDistance = Infinity;
                
                for (const stop of this.busStops) {
                    const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], stopCoords);
                    
                    if (distance < minStopDistance) {
                        minStopDistance = distance;
                        closestStop = stop;
                    }
                }
                
                if (!closestStop) return;
                
                // Find route point closest to this bus stop
                const stopCoords = [parseFloat(closestStop['Latitude']), parseFloat(closestStop['Longitude'])];
                let bestRouteIndex = 0;
                let minRouteDistance = Infinity;
                
                for (let i = 0; i < this.snappedRoute.length; i++) {
                    const routePoint = this.snappedRoute[i];
                    const distance = this.calculateDistance(stopCoords, routePoint);
                    
                    if (distance < minRouteDistance) {
                        minRouteDistance = distance;
                        bestRouteIndex = i;
                    }
                }
                
                // Snap bus to route point near the current bus stop
                const snapPoint = this.snappedRoute[bestRouteIndex];
                this.currentLocationMarker.setLatLng([snapPoint[0], snapPoint[1]]);
                this.currentRouteIndex = bestRouteIndex;
                
                console.log(`Bus snapped to route point ${bestRouteIndex}/${this.snappedRoute.length} near ${closestStop['Stop Name']}`);
                
                // Update info label
                if (this.updateBusInfoLabel) {
                    this.updateBusInfoLabel([snapPoint[0], snapPoint[1]], this.currentSpeed || 10, this.busIgnition);
                }
            }
            
            // Force snap to route and prevent GPS override
            forceSnapToRoute() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0 || !this.busStops) {
                    return;
                }
                
                // Find current bus stop based on GPS tracking logic
                const currentPos = this.currentLocationMarker.getLatLng();
                const currentHour = new Date().getHours();
                const isEvening = currentHour >= 12;
                const orderColumn = isEvening ? 'Evening Order' : 'Morning Order';
                
                let closestStop = null;
                let minDistance = Infinity;
                
                for (const stop of this.busStops) {
                    const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], stopCoords);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestStop = stop;
                    }
                }
                
                if (!closestStop) return;
                
                const currentOrder = parseInt(closestStop[orderColumn]);
                
                // Calculate route position based on bus progress (order 26 of 39 stops)
                // Since we're at 67% of route completion, use corresponding route point
                const routeProgress = (currentOrder - 1) / 38; // 0-based index for 39 stops
                let targetRouteIndex = Math.floor(routeProgress * (this.snappedRoute.length - 1));
                targetRouteIndex = Math.max(0, Math.min(targetRouteIndex, this.snappedRoute.length - 1));
                
                // Snap to route point
                const snapPoint = this.snappedRoute[targetRouteIndex];
                this.currentLocationMarker.setLatLng([snapPoint[0], snapPoint[1]]);
                this.currentRouteIndex = targetRouteIndex;
                
                console.log(`Force snapped to route point ${targetRouteIndex} for stop ${closestStop['Stop Name']} (order ${currentOrder})`);
                
                // Update info with snapped coordinates
                if (this.updateBusInfoLabel) {
                    this.updateBusInfoLabel([snapPoint[0], snapPoint[1]], this.currentSpeed || 10, this.busIgnition);
                }
                
                // Mark as force-snapped to prevent GPS override
                this.isForceSnapped = true;
            }
            
            // Get correct route position based on bus progress
            getCorrectRoutePosition(gpsLat, gpsLng) {
                if (!this.busStops || !this.snappedRoute || this.snappedRoute.length === 0) {
                    return null;
                }
                
                // Find current bus stop based on GPS coordinates
                let closestStop = null;
                let minDistance = Infinity;
                
                for (const stop of this.busStops) {
                    const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                    const distance = this.calculateDistance([gpsLat, gpsLng], stopCoords);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestStop = stop;
                    }
                }
                
                if (!closestStop) return null;
                
                // Get current order (bus is at order 26 based on logs)
                const currentHour = new Date().getHours();
                const isEvening = currentHour >= 12;
                const orderColumn = isEvening ? 'Evening Order' : 'Morning Order';
                const currentOrder = parseInt(closestStop[orderColumn]);
                
                // Map bus progress to route index (order 26 of 39 = 67% completion)
                const routeProgress = Math.min(0.99, Math.max(0.01, (currentOrder - 1) / 38));
                const targetRouteIndex = Math.floor(routeProgress * (this.snappedRoute.length - 1));
                
                console.log(`Route mapping: Order ${currentOrder}/39 (${(routeProgress*100).toFixed(1)}%) -> Route point ${targetRouteIndex}/${this.snappedRoute.length}`);
                
                return this.snappedRoute[targetRouteIndex];
            }
            
            // Snap bus to correct route position immediately
            snapBusToCorrectRoutePosition() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0) {
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                
                // Calculate route position based on GPS proximity to bus stops
                const routeCoords = this.getCorrectRoutePosition(currentPos.lat, currentPos.lng);
                if (routeCoords) {
                    // Override marker position with snapped coordinates
                    this.currentLocationMarker.setLatLng([routeCoords[0], routeCoords[1]]);
                    
                    // Update last known position
                    this.lastBusLocation = [routeCoords[0], routeCoords[1]];
                    
                    console.log(`Bus position overridden: GPS [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}] -> Route [${routeCoords[0].toFixed(6)}, ${routeCoords[1].toFixed(6)}]`);
                    
                    // Update popup with snapped coordinates
                    this.updateBusInfoLabel([routeCoords[0], routeCoords[1]], this.currentSpeed || 10, this.busIgnition);
                }
            }
            
            // Enforce route alignment after GPS updates
            enforceRouteAlignment() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0) {
                    console.log('Cannot enforce route alignment - missing data');
                    return;
                }
                
                // Get current GPS position
                const currentPos = this.currentLocationMarker.getLatLng();
                
                // Find bus progress based on distance to stops (bus is at order 26 = MEENANGADI POLICE ST)
                // Map to route index: order 26 of 39 stops = 66.7% progress
                const busProgress = 0.667; // Currently at stop 26 of 39
                const targetRouteIndex = Math.floor(busProgress * (this.snappedRoute.length - 1));
                
                // Get snapped route coordinates
                const snapCoords = this.snappedRoute[targetRouteIndex];
                
                // Force bus to route position
                this.currentLocationMarker.setLatLng([snapCoords[0], snapCoords[1]]);
                this.lastBusLocation = [snapCoords[0], snapCoords[1]];
                
                console.log(`Route alignment enforced: GPS [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}] -> Route point ${targetRouteIndex} [${snapCoords[0].toFixed(6)}, ${snapCoords[1].toFixed(6)}]`);
                
                // Update bus info with route coordinates
                if (this.updateBusInfoLabel) {
                    this.updateBusInfoLabel([snapCoords[0], snapCoords[1]], this.currentSpeed || 10, this.busIgnition);
                }
                
                // Store route index for continuous movement
                this.currentRouteIndex = targetRouteIndex;
            }
            
            // Continuous movement along snapped route between GPS updates
            startContinuousSnappedMovement() {
                console.log('Starting continuous snapped route movement');
                
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    console.log('No snapped route available for continuous movement');
                    return;
                }
                
                // Clear existing timers
                if (this.continuousTimer) {
                    clearInterval(this.continuousTimer);
                }
                
                this.currentSpeed = Math.max(5, Math.min(15, this.currentSpeed || 10));
                this.currentRouteIndex = this.findClosestRoutePoint();
                
                console.log(`Starting from route point ${this.currentRouteIndex}/${this.snappedRoute.length} at ${this.currentSpeed}km/h`);
                
                // Move every 5 seconds for visible progress
                this.continuousTimer = setInterval(() => {
                    this.performContinuousMovement();
                }, 5000);
            }
            
            performContinuousMovement() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0) return;
                
                // Calculate points to advance based on current speed
                const metersPerSecond = (this.currentSpeed * 1000) / 3600;
                const moveMeters = metersPerSecond * 5; // 5 seconds worth
                const pointsToAdvance = Math.max(1, Math.round(moveMeters / 25)); // ~25m between points
                
                // Advance along route
                this.currentRouteIndex = Math.min(this.currentRouteIndex + pointsToAdvance, this.snappedRoute.length - 1);
                
                const routePoint = this.snappedRoute[this.currentRouteIndex];
                
                // Move bus to next route point
                this.currentLocationMarker.setLatLng([routePoint[0], routePoint[1]]);
                
                // Find nearest bus stop
                let nearestStop = null;
                let minDistance = Infinity;
                
                if (this.busStops) {
                    for (const stop of this.busStops) {
                        const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                        const distance = this.calculateDistance([routePoint[0], routePoint[1]], stopCoords) * 1000;
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestStop = stop;
                        }
                    }
                }
                
                const stopName = nearestStop ? nearestStop['Stop Name'] : 'Unknown';
                console.log(`Continuous movement: point ${this.currentRouteIndex}/${this.snappedRoute.length} - near ${stopName} (${minDistance.toFixed(0)}m)`);
                
                // Stop at bus stops
                if (nearestStop && minDistance < 50) {
                    console.log(`Reached ${nearestStop['Stop Name']} during continuous movement - pausing`);
                    clearInterval(this.continuousTimer);
                    
                    setTimeout(() => {
                        console.log(`Resuming continuous movement from ${nearestStop['Stop Name']}`);
                        this.startContinuousSnappedMovement();
                    }, 10000);
                }
                
                // Check if reached end of route
                if (this.currentRouteIndex >= this.snappedRoute.length - 1) {
                    console.log('Reached end of route during continuous movement');
                    clearInterval(this.continuousTimer);
                }
            }
            
            moveAlongSnappedRoute() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0) return;
                
                // Initialize route index if not set
                if (this.currentRouteIndex === undefined) {
                    this.currentRouteIndex = this.findClosestRoutePoint();
                }
                
                // Use gradual speed between 5-15 km/h (GPS updates will override this)
                const currentSpeed = Math.max(5, Math.min(15, this.currentSpeed || 10));
                
                // Calculate points to advance based on speed
                const metersPerSecond = (currentSpeed * 1000) / 3600;
                const moveMeters = metersPerSecond * 3; // 3 seconds interval
                const pointsToAdvance = Math.max(1, Math.round(moveMeters / 25)); // ~25m between route points
                
                // Advance along the 764 snapped route points
                this.currentRouteIndex = Math.min(this.currentRouteIndex + pointsToAdvance, this.snappedRoute.length - 1);
                
                const routePoint = this.snappedRoute[this.currentRouteIndex];
                
                // Move bus to exact snapped route coordinate
                this.currentLocationMarker.setLatLng([routePoint[0], routePoint[1]]);
                
                // Find nearest bus stop to current position
                let nearestStop = null;
                let minDistance = Infinity;
                
                if (this.busStops) {
                    for (const stop of this.busStops) {
                        const stopCoords = [parseFloat(stop['Latitude']), parseFloat(stop['Longitude'])];
                        const distance = this.calculateDistance([routePoint[0], routePoint[1]], stopCoords) * 1000;
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestStop = stop;
                        }
                    }
                }
                
                const stopName = nearestStop ? nearestStop['Stop Name'] : 'Unknown';
                console.log(`Route point ${this.currentRouteIndex}/${this.snappedRoute.length} at ${currentSpeed}km/h - near ${stopName} (${minDistance.toFixed(0)}m)`);
                
                // Check if reached end of route
                if (this.currentRouteIndex >= this.snappedRoute.length - 1) {
                    console.log('Reached end of route');
                    clearInterval(this.routeTimer);
                    return;
                }
                
                // Stop at bus stops within 50m
                if (nearestStop && minDistance < 50) {
                    console.log(`Reached ${nearestStop['Stop Name']} - stopping for 10 seconds`);
                    clearInterval(this.routeTimer);
                    
                    setTimeout(() => {
                        console.log(`Departing ${nearestStop['Stop Name']}`);
                        this.startSnappedRouteMovement();
                    }, 10000);
                }
            }
            
            findClosestRoutePoint() {
                if (!this.currentLocationMarker || !this.snappedRoute || this.snappedRoute.length === 0) {
                    return 0;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                let closestIndex = 0;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.snappedRoute.length; i++) {
                    const routePoint = this.snappedRoute[i];
                    const distance = this.calculateDistance([currentPos.lat, currentPos.lng], routePoint);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                console.log(`ðŸ“ Starting from route point ${closestIndex}/${this.snappedRoute.length}`);
                return closestIndex;
            }

            // Trigger movement manually for immediate effect
            forceMovementNow() {
                console.log(`ðŸ’¥ FORCING MOVEMENT NOW - MANUAL TRIGGER`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ BEFORE: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                // Move 100 meters toward KAPPIKUNNU 2 (next stop)
                const kappikunnu2Coords = [11.689444, 76.162222]; // KAPPIKUNNU 2 coordinates
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], kappikunnu2Coords);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, 0.1); // 100 meters
                
                // Apply movement immediately
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, 25, "ON");
                
                console.log(`ðŸ“ AFTER: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                console.log(`ðŸ§­ BEARING: ${bearing.toFixed(1)}Â° toward KAPPIKUNNU 2`);
                
                const distance = this.calculateDistance(newPos, kappikunnu2Coords) * 1000;
                console.log(`ðŸ“ REMAINING: ${distance.toFixed(0)}m to KAPPIKUNNU 2`);
            }

            performDirectMovement(speed) {
                console.log(`ðŸš€ DIRECT MOVEMENT at ${speed} km/h`);
                
                if (!this.currentLocationMarker) {
                    console.log('âŒ No bus marker');
                    return;
                }
                
                const currentPos = this.currentLocationMarker.getLatLng();
                console.log(`ðŸ“ FROM: [${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}]`);
                
                // Get next stop in sequence
                const nextStop = this.getNextBusStop([currentPos.lat, currentPos.lng]);
                if (!nextStop) {
                    console.log('âŒ No next stop found');
                    return;
                }
                
                const targetCoords = nextStop.coordinates;
                console.log(`ðŸŽ¯ TO: ${nextStop['Stop Name']} at [${targetCoords[0].toFixed(6)}, ${targetCoords[1].toFixed(6)}]`);
                
                // Calculate movement distance (3 seconds worth)
                const metersPerSecond = (speed * 1000) / 3600;
                const moveMeters = metersPerSecond * 3;
                const moveKm = moveMeters / 1000;
                
                console.log(`ðŸš€ MOVING: ${moveMeters.toFixed(1)}m toward ${nextStop['Stop Name']}`);
                
                // Calculate bearing and new position
                const bearing = this.calculateBearing([currentPos.lat, currentPos.lng], targetCoords);
                const newPos = this.movePointByDistance([currentPos.lat, currentPos.lng], bearing, moveKm);
                
                // Apply movement
                this.currentLocationMarker.setLatLng(newPos);
                this.updateBusInfoLabel(newPos, speed, this.busIgnition);
                
                console.log(`ðŸšŒ MOVED TO: [${newPos[0].toFixed(6)}, ${newPos[1].toFixed(6)}]`);
                console.log(`ðŸ§­ BEARING: ${bearing.toFixed(1)}Â° toward APPAD SCHOOL ROAD`);
                
                const remainingDistance = this.calculateDistance(newPos, targetCoords) * 1000;
                console.log(`ðŸ“ REMAINING: ${remainingDistance.toFixed(0)}m to APPAD SCHOOL ROAD`);
                
                // Stop when close to destination
                if (remainingDistance < 100) {
                    console.log(`ðŸ›‘ REACHED APPAD SCHOOL ROAD - stopping direct movement`);
                    clearInterval(this.directTimer);
                }
            }

            calculateMovementDirection() {
                // Try to determine movement direction from route data
                if (this.routeLayer && this.routeLayer.getLatLngs) {
                    const routePoints = this.routeLayer.getLatLngs();
                    if (routePoints.length > 1) {
                        // Find closest route point and use direction along route
                        const busPos = this.currentLocationMarker ? this.currentLocationMarker.getLatLng() : null;
                        if (busPos) {
                            let closestIndex = 0;
                            let minDistance = Infinity;
                            
                            routePoints.forEach((point, index) => {
                                const distance = busPos.distanceTo(point);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestIndex = index;
                                }
                            });
                            
                            // Use direction from current point to next point on route
                            if (closestIndex < routePoints.length - 1) {
                                const current = routePoints[closestIndex];
                                const next = routePoints[closestIndex + 1];
                                const latDiff = next.lat - current.lat;
                                const lngDiff = next.lng - current.lng;
                                const magnitude = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                                
                                if (magnitude > 0) {
                                    return {
                                        lat: latDiff / magnitude,
                                        lng: lngDiff / magnitude
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Fallback: use general eastward direction
                return { lat: 0, lng: 0.0001 };
            }

            checkNearbyBusStop(position) {
                if (!this.stopMarkers || this.stopMarkers.length === 0) {
                    return null;
                }
                
                const busLatLng = L.latLng(position[0], position[1]);
                const stopRadius = 50; // 50 meters detection radius
                
                for (let stopData of this.stopMarkers) {
                    const stopLatLng = L.latLng(stopData.coordinates[0], stopData.coordinates[1]);
                    const distance = busLatLng.distanceTo(stopLatLng); // Distance in meters
                    
                    if (distance <= stopRadius) {
                        return stopData;
                    }
                }
                
                return null;
            }

            animateBusMovement(fromLatLng, toLatLng, speed) {
                const duration = Math.max(1000, Math.min(5000, 15000 - (speed * 100))); // Adjust animation speed
                const steps = 30;
                let currentStep = 0;
                
                const latDiff = toLatLng[0] - fromLatLng[0];
                const lngDiff = toLatLng[1] - fromLatLng[1];
                
                const animate = () => {
                    currentStep++;
                    const progress = currentStep / steps;
                    
                    // Easing function for smooth movement
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    const currentLat = fromLatLng[0] + (latDiff * easeProgress);
                    const currentLng = fromLatLng[1] + (lngDiff * easeProgress);
                    
                    this.currentLocationMarker.setLatLng([currentLat, currentLng]);
                    
                    // Update bus info label position during animation
                    if (this.busInfoLabel) {
                        this.updateBusInfoLabel([currentLat, currentLng]);
                    }
                    
                    if (currentStep < steps) {
                        setTimeout(animate, duration / steps);
                    }
                };
                
                animate();
            }

            updateBusInfoLabel(busLocation) {
                let labelText = `Bus No ${this.BUS_NUMBER}`;
                
                // Check if bus is idle (ignition OFF)
                if (this.busIgnition === 'OFF' || this.busIgnition === 'FALSE' || this.busIgnition === false) {
                    labelText += ', IDLE';
                } else {
                    const etas = this.calculateETA();
                    if (etas.length > 0) {
                        const nextStop = etas[0];
                        labelText += `, ${nextStop.eta} mins to Stop ${nextStop.order}: ${nextStop.stop['Stop Name']}`;
                    } else {
                        labelText += ', Calculating ETA...';
                    }
                }
                
                if (!this.busInfoLabel) {
                    // Create the label element
                    this.busInfoLabel = document.createElement('div');
                    this.busInfoLabel.className = 'bus-info-label';
                    document.body.appendChild(this.busInfoLabel);
                }
                
                // Update label text
                this.busInfoLabel.textContent = labelText;
                
                // Position the label next to the bus icon
                const busPixelPosition = this.map.latLngToContainerPoint(busLocation);
                const labelWidth = this.busInfoLabel.offsetWidth || 150;
                
                // Position to the right of the bus icon with some offset
                this.busInfoLabel.style.left = (busPixelPosition.x + 45) + 'px';
                this.busInfoLabel.style.top = (busPixelPosition.y - 15) + 'px';
                
                // Keep label visible on screen
                const mapContainer = this.map.getContainer();
                const mapWidth = mapContainer.offsetWidth;
                const mapHeight = mapContainer.offsetHeight;
                
                // Adjust position if label would go off-screen
                if (busPixelPosition.x + 45 + labelWidth > mapWidth) {
                    this.busInfoLabel.style.left = (busPixelPosition.x - labelWidth - 45) + 'px';
                }
                
                if (busPixelPosition.y - 15 < 0) {
                    this.busInfoLabel.style.top = (busPixelPosition.y + 45) + 'px';
                }
            }

            async displayHistoricalRoute(historicalData) {
                // Use the provided filtered route coordinates for Bus No 4
                const routeCoordinates = [
                    [11.707203, 76.178753], [11.707203, 76.178753], [11.707043, 76.178674], [11.703089, 76.176372],
                    [11.70215, 76.175898], [11.699329, 76.174175], [11.698983, 76.173874], [11.69897, 76.173627],
                    [11.69897, 76.173627], [11.693091, 76.175683], [11.693091, 76.175683], [11.693091, 76.175683],
                    [11.692489, 76.171257], [11.692894, 76.169505], [11.690033, 76.163223], [11.690155, 76.162754],
                    [11.690275, 76.162408], [11.69037, 76.161508], [11.690206, 76.160369], [11.690047, 76.163146],
                    [11.690286, 76.163855], [11.691306, 76.165319], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104], [11.691746, 76.166104],
                    [11.68323, 76.1649], [11.68323, 76.1649], [11.679817, 76.16187], [11.674429, 76.158919],
                    [11.674429, 76.158919], [11.673687, 76.157864], [11.673431, 76.156758], [11.670298, 76.150902],
                    [11.672108, 76.148321], [11.672297, 76.147892], [11.672262, 76.148062], [11.66598, 76.157013],
                    [11.665356, 76.158277], [11.665356, 76.158277], [11.663222, 76.160824], [11.658865, 76.16108],
                    [11.657806, 76.160551], [11.65776, 76.160523], [11.65776, 76.160523], [11.653527, 76.154115],
                    [11.65327, 76.143409], [11.652043, 76.142324], [11.651361, 76.141892], [11.651361, 76.141892],
                    [11.638766, 76.145734], [11.638079, 76.147841], [11.636767, 76.149675], [11.631102, 76.150658],
                    [11.623348, 76.156827], [11.619435, 76.15801], [11.619255, 76.158062], [11.61907, 76.158193],
                    [11.619354, 76.167932], [11.619354, 76.167932], [11.617481, 76.160904], [11.619013, 76.158224],
                    [11.619173, 76.158089], [11.629105, 76.152701], [11.62928, 76.15247], [11.638774, 76.145684],
                    [11.639721, 76.14539], [11.640015, 76.145458], [11.650805, 76.141346], [11.649996, 76.140488],
                    [11.649307, 76.137058], [11.649246, 76.134996], [11.649136, 76.132484], [11.648907, 76.128197],
                    [11.64229, 76.110991], [11.641959, 76.110759], [11.641778, 76.110718], [11.641778, 76.110718],
                    [11.641694, 76.110861], [11.63811, 76.101998], [11.636936, 76.10055], [11.63609, 76.0916],
                    [11.634211, 76.090231], [11.634222, 76.090191], [11.634222, 76.090191], [11.636535, 76.097234],
                    [11.637145, 76.100888], [11.641326, 76.109974]
                ];

                console.log(`Displaying route with ${routeCoordinates.length} coordinate points`);

                try {
                    // Attempt to get road-snapped route from OpenRouteService
                    const snappedRoute = await this.getSnappedRoute(routeCoordinates);
                    
                    if (snappedRoute && snappedRoute.length > 0) {
                        console.log(`Got snapped route with ${snappedRoute.length} points`);
                        
                        // Create route polyline using snapped coordinates
                        this.routeLayer = L.polyline(snappedRoute, {
                            color: '#ff9800',
                            weight: 4,
                            opacity: 0.8
                        }).addTo(this.map);

                        // Direction arrows removed - confusing on bidirectional roads

                        // Add popup to route
                        this.routeLayer.bindPopup(`
                            <div class="custom-popup">
                                <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                                <p><strong>Date:</strong> June 25, 2025</p>
                                <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                                <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                                <p><em>Road-snapped route via OpenRouteService</em></p>
                            </div>
                        `);
                    } else {
                        throw new Error('No snapped route returned');
                    }
                } catch (error) {
                    console.warn('Road snapping failed, using GPS coordinates:', error.message);
                    
                    // Fallback: Create route polyline using the filtered coordinates
                    this.routeLayer = L.polyline(routeCoordinates, {
                        color: '#ff9800',
                        weight: 4,
                        opacity: 0.8,
                        dashArray: '10, 5'
                    }).addTo(this.map);

                    // Add popup to route
                    this.routeLayer.bindPopup(`
                        <div class="custom-popup">
                            <h4>Bus No ${this.BUS_NUMBER} - Historical Route</h4>
                            <p><strong>Date:</strong> June 25, 2025</p>
                            <p><strong>Time:</strong> 3:30 PM - 5:30 PM</p>
                            <p><strong>Route Points:</strong> ${routeCoordinates.length}</p>
                            <p><em>GPS trail (road snapping unavailable)</em></p>
                        </div>
                    `);
                }

                // Fit map to show the complete route
                this.map.fitBounds(this.routeLayer.getBounds(), { padding: [20, 20] });
            }

            async getSnappedRoute(coordinates) {
                try {
                    // Fetch pre-computed snapped route from SnappedRoutes sheet
                    console.log('Fetching pre-computed snapped route from SnappedRoutes sheet');
                    const snappedData = await this.fetchData(`${this.SHEETS_BASE_URL}/SnappedRoutes`);
                    
                    // Filter for Bus No 4 route (June 25, 3:30-5:30 PM)
                    const bus4SnappedRoute = snappedData.filter(row => 
                        row['Route Name'] === 'Bus4_June25_1530_1730'
                    );
                    
                    if (bus4SnappedRoute.length > 0) {
                        // Sort by point order and convert to coordinate pairs
                        bus4SnappedRoute.sort((a, b) => parseInt(a['Point Order']) - parseInt(b['Point Order']));
                        
                        const snappedCoords = bus4SnappedRoute.map(row => [
                            parseFloat(row['Latitude']),
                            parseFloat(row['Longitude'])
                        ]);
                        
                        console.log(`âœ“ Using pre-computed snapped route with ${snappedCoords.length} points`);
                        return snappedCoords;
                    } else {
                        console.warn('No pre-computed snapped route found, using GPS coordinates');
                        return [];
                    }
                    
                } catch (error) {
                    console.error('Error fetching snapped route:', error);
                    console.log('Falling back to GPS coordinates');
                    return [];
                }
            }

            // Convert degrees/minutes/seconds to decimal degrees
            convertDMSToDecimal(dmsString) {
                try {
                    // Handle format like "11Â°38'04.3"N " or "76Â°05'24.8"E"
                    // Remove all quotes, extra spaces, and clean the string
                    const cleanString = dmsString.replace(/"/g, '').trim().replace(/\s+/g, '');
                    
                    // Match pattern: degreesÂ°minutes'seconds"direction or degreesÂ°minutes'secondsdirection
                    const parts = cleanString.match(/(\d+)Â°(\d+)'([\d.]+)([NSEW])/);
                    
                    if (!parts) {
                        console.warn('Could not parse DMS string:', dmsString, 'cleaned to:', cleanString);
                        return NaN;
                    }
                    
                    const degrees = parseInt(parts[1]);
                    const minutes = parseInt(parts[2]);
                    const seconds = parseFloat(parts[3]);
                    const direction = parts[4];
                    
                    let decimal = degrees + (minutes / 60) + (seconds / 3600);
                    
                    if (direction === 'S' || direction === 'W') {
                        decimal = -decimal;
                    }
                    
                    return decimal;
                } catch (error) {
                    console.warn('Error converting DMS to decimal:', dmsString, error);
                    return NaN;
                }
            }

            displayBusStops(busStops) {
                console.log(`Processing ${busStops.length} bus stops`);
                
                // Determine if this is morning or evening run based on current time
                const currentHour = new Date().getHours();
                const isEveningRun = currentHour >= 15; // After 3 PM is evening run
                const orderColumn = isEveningRun ? 'Evening Order' : 'Morning Order';
                
                console.log(`Using ${orderColumn} for bus stop ordering (current hour: ${currentHour})`);
                
                // Sort bus stops by the appropriate order column
                const sortedStops = busStops.sort((a, b) => {
                    const orderA = parseInt(a[orderColumn]) || 999;
                    const orderB = parseInt(b[orderColumn]) || 999;
                    return orderA - orderB;
                });
                
                sortedStops.forEach((stop, index) => {
                    let lat, lng;
                    
                    // Check if coordinates are in DMS format (contain Â° character)
                    if (stop['Latitude'].includes('Â°')) {
                        lat = this.convertDMSToDecimal(stop['Latitude']);
                        lng = this.convertDMSToDecimal(stop['Longitude']);
                    } else {
                        lat = parseFloat(stop['Latitude']);
                        lng = parseFloat(stop['Longitude']);
                    }

                    if (isNaN(lat) || isNaN(lng)) {
                        console.warn(`Invalid coordinates for stop: ${stop['Stop Name']}`, stop['Latitude'], stop['Longitude']);
                        return;
                    }
                    
                    const stopOrder = parseInt(stop[orderColumn]) || (index + 1);

                    // Create bus stop icon
                    const stopIcon = L.divIcon({
                        className: 'stop-icon',
                        html: `
                            <div style="
                                background-color: #2196f3;
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                border: 2px solid #fff;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                color: white;
                                font-size: 10px;
                                font-weight: bold;
                            ">${stopOrder}</div>
                        `,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    const marker = L.marker([lat, lng], { icon: stopIcon })
                        .addTo(this.map)
                        .bindPopup(`
                            <div class="custom-popup">
                                <h4>${stop['Stop Name'] || 'Bus Stop'}</h4>
                                <p><strong>Bus Number:</strong> ${stop['Bus Number']}</p>
                                <p><strong>${orderColumn}:</strong> ${stopOrder}</p>
                                <p><strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        `);

                    this.stopMarkers.push({
                        marker: marker,
                        stop: stop,
                        order: stopOrder,
                        coordinates: [lat, lng]
                    });
                });
            }

            // Direction arrows removed - confusing on bidirectional roads

            calculateBearing(from, to) {
                const lat1 = from[0] * Math.PI / 180;
                const lat2 = to[0] * Math.PI / 180;
                const deltaLon = (to[1] - from[1]) * Math.PI / 180;
                
                const y = Math.sin(deltaLon) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
                
                const bearing = Math.atan2(y, x) * 180 / Math.PI;
                return (bearing + 360) % 360;
            }

            movePointByDistance(point, bearing, distanceKm) {
                const R = 6371; // Earth's radius in km
                const lat1 = point[0] * Math.PI / 180;
                const lon1 = point[1] * Math.PI / 180;
                const bearingRad = bearing * Math.PI / 180;
                
                const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distanceKm / R) +
                                     Math.cos(lat1) * Math.sin(distanceKm / R) * Math.cos(bearingRad));
                
                const lon2 = lon1 + Math.atan2(Math.sin(bearingRad) * Math.sin(distanceKm / R) * Math.cos(lat1),
                                              Math.cos(distanceKm / R) - Math.sin(lat1) * Math.sin(lat2));
                
                return [lat2 * 180 / Math.PI, lon2 * 180 / Math.PI];
            }

            calculateDistance(point1, point2) {
                const R = 6371; // Earth's radius in km
                const lat1 = point1[0] * Math.PI / 180;
                const lat2 = point2[0] * Math.PI / 180;
                const deltaLat = (point2[0] - point1[0]) * Math.PI / 180;
                const deltaLon = (point2[1] - point1[1]) * Math.PI / 180;
                
                const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(deltaLon/2) * Math.sin(deltaLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c; // Distance in km
            }

            calculateETA() {
                if (!this.lastBusLocation || this.stopMarkers.length === 0) {
                    return [];
                }
                
                const busLocation = this.lastBusLocation;
                // Use fixed speed for ETA calculations based on distance only
                const speed = 25; // Fixed 25 km/h for consistent ETA calculations
                
                // Find next stops based on order sequence, not route position
                const nextStops = this.findNextStopsInOrder(busLocation);
                const etas = [];
                
                console.log(`Found ${nextStops.length} upcoming stops:`, nextStops.map(s => `${s.order}: ${s.stop['Stop Name']}`));
                
                // Calculate ETA for next stops using route-following distance
                nextStops.forEach(stopData => {
                    // Use route-following distance instead of straight-line distance
                    const routeDistance = this.calculateRouteDistance(busLocation, stopData.coordinates);
                    const distance = routeDistance > 0 ? routeDistance : this.calculateDistance(busLocation, stopData.coordinates);
                    const timeInHours = distance / speed;
                    const timeInMinutes = Math.round(timeInHours * 60);
                    
                    console.log(`ETA to ${stopData.stop['Stop Name']} (order ${stopData.order}): ${timeInMinutes} mins (${distance.toFixed(2)} km) via route`);
                    
                    etas.push({
                        stop: stopData.stop,
                        order: stopData.order,
                        distance: distance,
                        eta: timeInMinutes
                    });
                });
                
                return etas;
            }

            // Calculate distance following the actual route with waypoints
            calculateRouteDistance(fromCoord, toCoord) {
                try {
                    if (!this.snappedRoute || this.snappedRoute.length === 0) {
                        return 0; // Fallback to straight-line distance
                    }
                    
                    // Find current position on route
                    const currentIndex = this.findNearestRoutePoint(fromCoord);
                    const targetIndex = this.findNearestRoutePoint(toCoord);
                    
                    if (currentIndex === -1 || targetIndex === -1) {
                        return 0; // Fallback to straight-line distance
                    }
                    
                    // Calculate cumulative distance along route
                    let totalDistance = 0;
                    const startIndex = Math.min(currentIndex, targetIndex);
                    const endIndex = Math.max(currentIndex, targetIndex);
                    
                    for (let i = startIndex; i < endIndex; i++) {
                        const point1 = this.snappedRoute[i];
                        const point2 = this.snappedRoute[i + 1];
                        if (point1 && point2) {
                            totalDistance += this.calculateDistance(point1, point2);
                        }
                    }
                    
                    return totalDistance;
                } catch (error) {
                    console.log('Route distance calculation failed, using straight-line');
                    return 0;
                }
            }

            // Find nearest point on the snapped route
            findNearestRoutePoint(coord) {
                if (!this.snappedRoute || this.snappedRoute.length === 0) {
                    return -1;
                }
                
                let nearestIndex = -1;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.snappedRoute.length; i++) {
                    const distance = this.calculateDistance(coord, this.snappedRoute[i]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestIndex = i;
                    }
                }
                
                return nearestIndex;
            }

            findNextStopsInOrder(busLocation) {
                if (this.stopMarkers.length === 0) return [];
                
                // Find the next upcoming stops based on distance from current position
                // Calculate distance to all stops and find the closest one
                let currentStopIndex = -1;
                let minDistance = Infinity;
                
                this.stopMarkers.forEach((stopData, index) => {
                    const distance = this.calculateDistance(busLocation, stopData.coordinates);
                    if (distance < minDistance) {
                        minDistance = distance;
                        currentStopIndex = index;
                    }
                });
                
                // Find the next stops that haven't been passed yet
                const nextStops = [];
                
                // Start from the closest stop and look for upcoming stops
                console.log(`Closest stop: ${this.stopMarkers[currentStopIndex]?.stop['Stop Name']} at ${minDistance.toFixed(3)} km`);
                
                // Find the next stops strictly following the order sequence
                // Start from the stop after the closest one in the sequence
                const currentOrder = this.stopMarkers[currentStopIndex]?.order || 0;
                
                console.log(`Current position closest to order ${currentOrder}, looking for next stops in sequence`);
                
                // Intelligent ETA system for U-turn routes
                // Only show stops that are genuinely ahead in the journey
                
                console.log(`Current bus position: [${busLocation[0].toFixed(6)}, ${busLocation[1].toFixed(6)}]`);
                
                // Simple sequential logic: just find next 5 stops in route order
                for (let i = 0; i < this.stopMarkers.length && nextStops.length < 5; i++) {
                    const stopData = this.stopMarkers[i];
                    const distanceToStop = this.calculateDistance(busLocation, stopData.coordinates);
                    
                    // Skip stops that are too far (not relevant for current position)
                    if (distanceToStop > 8.0) {
                        console.log(`Skipped distant stop: ${stopData.stop['Stop Name']} (order ${stopData.order}) - ${distanceToStop.toFixed(2)}km away`);
                        continue;
                    }
                    
                    // Only include stops with higher order numbers (upcoming in sequence)
                    if (stopData.order > currentOrder) {
                        nextStops.push(stopData);
                        console.log(`Added upcoming stop: ${stopData.stop['Stop Name']} (order ${stopData.order}) - ${distanceToStop.toFixed(2)}km away`);
                    } else {
                        console.log(`Skipped past stop: ${stopData.stop['Stop Name']} (order ${stopData.order}) - already passed`);
                    }
                }
                
                // Sort by order to maintain route sequence
                nextStops.sort((a, b) => a.order - b.order);
                
                // Sort by order to maintain proper sequence
                nextStops.sort((a, b) => a.order - b.order);
                
                console.log(`Final upcoming stops in order: ${nextStops.map(s => `${s.order}:${s.stop['Stop Name']}`).join(', ')}`);
                
                // If we ran out of stops in the sequence, we might be near the end of route
                if (nextStops.length === 0 && currentStopIndex >= this.stopMarkers.length - 1) {
                    console.log('Bus appears to be at or past the final stop');
                    return [];
                }
                
                // If still no stops found, take from current position
                if (nextStops.length === 0 && currentStopIndex >= 0) {
                    for (let i = currentStopIndex; i < this.stopMarkers.length && nextStops.length < 5; i++) {
                        nextStops.push(this.stopMarkers[i]);
                    }
                }
                
                return nextStops;
            }

            findNextStopsOnRoute(busLocation) {
                if (!this.routeLayer || !this.routeLayer.getLatLngs || this.stopMarkers.length === 0) {
                    // Fallback to distance-based sorting if route not available
                    return this.stopMarkers
                        .map(stop => ({
                            ...stop,
                            distanceFromBus: this.calculateDistance(busLocation, stop.coordinates)
                        }))
                        .sort((a, b) => a.distanceFromBus - b.distanceFromBus);
                }
                
                const routePoints = this.routeLayer.getLatLngs();
                const busLatLng = L.latLng(busLocation[0], busLocation[1]);
                
                // Find bus position on route
                let closestRouteIndex = 0;
                let minDistanceToRoute = Infinity;
                
                routePoints.forEach((point, index) => {
                    const distance = busLatLng.distanceTo(point);
                    if (distance < minDistanceToRoute) {
                        minDistanceToRoute = distance;
                        closestRouteIndex = index;
                    }
                });
                
                // Find stops ahead on the route
                const nextStops = [];
                
                this.stopMarkers.forEach(stopData => {
                    const stopLatLng = L.latLng(stopData.coordinates[0], stopData.coordinates[1]);
                    
                    // Find closest route point to this stop
                    let closestStopRouteIndex = 0;
                    let minDistanceToStopRoute = Infinity;
                    
                    routePoints.forEach((point, index) => {
                        const distance = stopLatLng.distanceTo(point);
                        if (distance < minDistanceToStopRoute) {
                            minDistanceToStopRoute = distance;
                            closestStopRouteIndex = index;
                        }
                    });
                    
                    // If stop is ahead of bus on route, include it
                    if (closestStopRouteIndex > closestRouteIndex) {
                        nextStops.push({
                            ...stopData,
                            routeIndex: closestStopRouteIndex,
                            distanceFromBus: this.calculateDistance(busLocation, stopData.coordinates)
                        });
                    }
                });
                
                // Sort by route order (position along route)
                return nextStops.sort((a, b) => a.routeIndex - b.routeIndex);
            }

            checkETAAlerts() {
                const etas = this.calculateETA();
                
                etas.forEach(eta => {
                    // Alert for 5 minutes or less
                    if (eta.eta <= 5 && eta.eta > 0) {
                        console.log(`ETA Alert: Bus No ${this.BUS_NUMBER} is ${eta.eta} mins away from ${eta.stop['Stop Name']} stop`);
                        this.showAlert(`Bus No ${this.BUS_NUMBER} will reach ${eta.stop['Stop Name']} stop in ${eta.eta} minutes`);
                    }
                    // Alert for 10 minutes or less (but more than 5)
                    else if (eta.eta <= 10 && eta.eta > 5) {
                        console.log(`ETA Alert: Bus No ${this.BUS_NUMBER} is ${eta.eta} mins away from ${eta.stop['Stop Name']} stop`);
                        this.showAlert(`Bus No ${this.BUS_NUMBER} will reach ${eta.stop['Stop Name']} stop in ${eta.eta} minutes`);
                    }
                });
                
                // Update ETA display in popup if it exists
                const etaElement = document.getElementById('next-stop-eta');
                if (etaElement && etas.length > 0) {
                    const nextStop = etas[0];
                    etaElement.textContent = `${nextStop.eta} mins to ${nextStop.stop['Stop Name']}`;
                }
            }

            showAlert(message) {
                // Create alert notification with improved styling
                const alertDiv = document.createElement('div');
                alertDiv.className = 'eta-alert';
                alertDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    background: linear-gradient(135deg, #4caf50, #45a049);
                    color: white;
                    padding: 16px 24px;
                    border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
                    z-index: 10000;
                    font-size: 15px;
                    font-weight: 500;
                    max-width: 320px;
                    min-width: 250px;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    backdrop-filter: blur(10px);
                    animation: slideInBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                    line-height: 1.4;
                `;
                
                // Add icon and better formatting
                const icon = 'ðŸšŒ';
                alertDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 20px;">${icon}</span>
                        <div>${message}</div>
                    </div>
                `;
                
                // Enhanced animation styles
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInBounce {
                        0% { 
                            transform: translateX(100%) scale(0.8); 
                            opacity: 0; 
                        }
                        50% { 
                            transform: translateX(-10px) scale(1.05); 
                            opacity: 0.8; 
                        }
                        100% { 
                            transform: translateX(0) scale(1); 
                            opacity: 1; 
                        }
                    }
                    @keyframes fadeOut {
                        from { 
                            transform: translateX(0) scale(1); 
                            opacity: 1; 
                        }
                        to { 
                            transform: translateX(100%) scale(0.8); 
                            opacity: 0; 
                        }
                    }
                `;
                if (!document.querySelector('#alert-animations')) {
                    style.id = 'alert-animations';
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(alertDiv);
                
                // Enhanced removal with fade out animation
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.style.animation = 'fadeOut 0.3s ease-in forwards';
                        setTimeout(() => {
                            if (alertDiv.parentNode) {
                                alertDiv.remove();
                            }
                        }, 300);
                    }
                }, 4000);
                
                console.log(`ETA Alert: ${message}`);
            }

            updateLastUpdateTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = `Last Update: ${timeString}`;
            }

            showLoading(show) {
                const overlay = document.getElementById('loadingOverlay');
                overlay.style.display = show ? 'flex' : 'none';
            }

            showError(message) {
                const errorElement = document.getElementById('errorMessage');
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 10000);
            }

            // Method to refresh data (can be called externally)
            async refresh() {
                await this.updateBusLocation();
            }
        }

        // Initialize the bus tracker when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.busTracker = new BusTracker();
        });

        // Telegram Web App specific initialization
        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>
